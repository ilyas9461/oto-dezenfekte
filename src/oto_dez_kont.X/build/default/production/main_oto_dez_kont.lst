CCS PCH C Compiler, Version 5.076, 56587               01-Eki-20 09:06

               Filename:   D:\EasyPICV6\CCS_PIC_C\proje_oto_dezenfekte_kontrol\src\oto_dez_kont.X\build\default\production\main_oto_dez_kont.lst

               ROM used:   13028 bytes (40%)
                           Largest free fragment is 19736
               RAM used:   365 (24%) at main() level
                           577 (38%) worst case
               Stack used: 6 locations (5 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   288E
*
0008:  GOTO   00B2
000C:  NOP   
000E:  NOP   
0010:  NOP   
0012:  NOP   
0014:  NOP   
0016:  NOP   
0018:  MOVWF  04
001A:  MOVFF  FD8,05
001E:  MOVFF  FE0,06
0022:  MOVLB  0
0024:  MOVFF  FE9,0C
0028:  MOVFF  FEA,07
002C:  MOVFF  FE1,08
0030:  MOVFF  FE2,09
0034:  MOVFF  FD9,0A
0038:  MOVFF  FDA,0B
003C:  MOVFF  FF3,12
0040:  MOVFF  FF4,13
0044:  MOVFF  FFA,14
0048:  MOVFF  FF5,15
004C:  MOVFF  FF6,16
0050:  MOVFF  FF7,17
0054:  MOVFF  00,0E
0058:  MOVFF  01,0F
005C:  MOVFF  02,10
0060:  MOVFF  03,11
0064:  MOVFF  0E,00
0068:  MOVFF  0F,01
006C:  MOVFF  10,02
0070:  MOVFF  11,03
0074:  MOVFF  0C,FE9
0078:  MOVFF  07,FEA
007C:  BSF    07.7
007E:  MOVFF  08,FE1
0082:  MOVFF  09,FE2
0086:  MOVFF  0A,FD9
008A:  MOVFF  0B,FDA
008E:  MOVFF  12,FF3
0092:  MOVFF  13,FF4
0096:  MOVFF  14,FFA
009A:  MOVFF  15,FF5
009E:  MOVFF  16,FF6
00A2:  MOVFF  17,FF7
00A6:  MOVF   04,W
00A8:  MOVFF  06,FE0
00AC:  MOVFF  05,FD8
00B0:  RETFIE 0
00B2:  MOVWF  19
00B4:  MOVFF  FD8,1A
00B8:  MOVFF  FE0,1B
00BC:  MOVLB  0
00BE:  MOVFF  FE9,21
00C2:  MOVFF  FEA,1C
00C6:  MOVFF  FE1,1D
00CA:  MOVFF  FE2,1E
00CE:  MOVFF  FD9,1F
00D2:  MOVFF  FDA,20
00D6:  MOVFF  FF3,27
00DA:  MOVFF  FF4,28
00DE:  MOVFF  FFA,29
00E2:  MOVFF  FF5,2A
00E6:  MOVFF  FF6,2B
00EA:  MOVFF  FF7,2C
00EE:  MOVFF  00,23
00F2:  MOVFF  01,24
00F6:  MOVFF  02,25
00FA:  MOVFF  03,26
00FE:  BTFSS  FF2.5
0100:  GOTO   010A
0104:  BTFSC  FF2.2
0106:  GOTO   03CA
010A:  MOVFF  23,00
010E:  MOVFF  24,01
0112:  MOVFF  25,02
0116:  MOVFF  26,03
011A:  MOVFF  21,FE9
011E:  MOVFF  1C,FEA
0122:  BSF    1C.7
0124:  MOVFF  1D,FE1
0128:  MOVFF  1E,FE2
012C:  MOVFF  1F,FD9
0130:  MOVFF  20,FDA
0134:  MOVFF  27,FF3
0138:  MOVFF  28,FF4
013C:  MOVFF  29,FFA
0140:  MOVFF  2A,FF5
0144:  MOVFF  2B,FF6
0148:  MOVFF  2C,FF7
014C:  MOVF   19,W
014E:  MOVFF  1B,FE0
0152:  MOVFF  1A,FD8
0156:  RETFIE 0
.................... /*  
....................  * File:   main_oto_dez_kont.c 
....................  * Author: ilyas 
....................  * 
....................  * Created on 22 Nisan 2020 Çarþamba, 12:10 
....................  */ 
....................  
.................... //#define BARIYER_SENS  
.................... #define PIR_SENS_TEKLI 
....................  
.................... #include "main_oto_dez_kont.h" 
.................... /*  
....................  * File:   main_oto_dez_kont.h 
....................  * Author: ilyas 
....................  * 
....................  * Created on 22 Nisan 2020 Çarþamba, 12:10 
....................  */ 
....................  
.................... #ifndef MAIN_OTO_DEZ_KONT_H 
.................... #define	MAIN_OTO_DEZ_KONT_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................      
....................     #include <C:\Program Files (x86)\PICC\Devices\18F45K22.h> //tam yolu yazmak dosyayý açamama hatasýný giderdi. 
.................... //////////// Standard Header file for the PIC18F45K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F45K22 
0158:  CLRF   FF7
015A:  ADDLW  68
015C:  MOVWF  FF6
015E:  MOVLW  01
0160:  ADDWFC FF7,F
0162:  TBLRD*+
0164:  MOVF   FF5,W
0166:  RETURN 0
0168:  DATA 54,55
016A:  DATA 52,4B
016C:  DATA 43,45
016E:  DATA 2C,46
0170:  DATA 52,41
0172:  DATA 4E,43
0174:  DATA 41,49
0176:  DATA 53,2C
0178:  DATA 44,65
017A:  DATA 75,74
017C:  DATA 73,63
017E:  DATA 68,2C
0180:  DATA 45,6E
0182:  DATA 67,6C
0184:  DATA 69,73
0186:  DATA 68,2C
0188:  DATA 00,00
018A:  CLRF   FF7
018C:  ADDLW  9A
018E:  MOVWF  FF6
0190:  MOVLW  01
0192:  ADDWFC FF7,F
0194:  TBLRD*+
0196:  MOVF   FF5,W
0198:  RETURN 0
019A:  DATA 4F,54
019C:  DATA 4F,20
019E:  DATA 44,45
01A0:  DATA 5A,45
01A2:  DATA 4E,46
01A4:  DATA 45,4B
01A6:  DATA 54,45
01A8:  DATA 2C,44
01AA:  DATA 65,70
01AC:  DATA 6F,2C
01AE:  DATA 53,75
01B0:  DATA 72,65
01B2:  DATA 2C,4F
01B4:  DATA 72,74
01B6:  DATA 61,2C
01B8:  DATA 4B,61
01BA:  DATA 79,64
01BC:  DATA 65,64
01BE:  DATA 69,6C
01C0:  DATA 64,69
01C2:  DATA 2C,53
01C4:  DATA 75,72
01C6:  DATA 65,20
01C8:  DATA 41,79
01CA:  DATA 61,72
01CC:  DATA 2C,44
01CE:  DATA 4F,4E
01D0:  DATA 41,4E
01D2:  DATA 49,4D
01D4:  DATA 20,4B
01D6:  DATA 4F,4E
01D8:  DATA 54,2E
01DA:  DATA 2C,44
01DC:  DATA 49,4C
01DE:  DATA 20,53
01E0:  DATA 45,43
01E2:  DATA 2C,43
01E4:  DATA 49,4B
01E6:  DATA 49,53
01E8:  DATA 2C,42
01EA:  DATA 4F,53
01EC:  DATA 2C,53
01EE:  DATA 61,79
01F0:  DATA 61,63
01F2:  DATA 2C,42
01F4:  DATA 65,6B
01F6:  DATA 6C,65
01F8:  DATA 6D,65
01FA:  DATA 20,53
01FC:  DATA 75,72
01FE:  DATA 65,73
0200:  DATA 69,2C
0202:  DATA 00,00
0204:  CLRF   FF7
0206:  ADDLW  14
0208:  MOVWF  FF6
020A:  MOVLW  02
020C:  ADDWFC FF7,F
020E:  TBLRD*+
0210:  MOVF   FF5,W
0212:  RETURN 0
0214:  DATA 44,65
0216:  DATA 73,69
0218:  DATA 6E,66
021A:  DATA 65,63
021C:  DATA 74,69
021E:  DATA 6F,6E
0220:  DATA 2E,2E
0222:  DATA 2E,2C
0224:  DATA 52,65
0226:  DATA 73,65
0228:  DATA 72,76
022A:  DATA 6F,69
022C:  DATA 72,2C
022E:  DATA 54,65
0230:  DATA 6D,70
0232:  DATA 73,2C
0234:  DATA 4D,69
0236:  DATA 6C,69
0238:  DATA 65,75
023A:  DATA 2C,45
023C:  DATA 6E,72
023E:  DATA 65,67
0240:  DATA 69,73
0242:  DATA 74,72
0244:  DATA 65,2C
0246:  DATA 52,65
0248:  DATA 67,6C
024A:  DATA 61,67
024C:  DATA 65,73
024E:  DATA 20,74
0250:  DATA 65,6D
0252:  DATA 70,73
0254:  DATA 2C,43
0256:  DATA 6F,6E
0258:  DATA 74,2E
025A:  DATA 20,6D
025C:  DATA 61,74
025E:  DATA 65,72
0260:  DATA 69,65
0262:  DATA 6C,2C
0264:  DATA 63,68
0266:  DATA 6F,69
0268:  DATA 73,69
026A:  DATA 73,73
026C:  DATA 65,7A
026E:  DATA 20,6C
0270:  DATA 61,6E
0272:  DATA 67,2E
0274:  DATA 2C,53
0276:  DATA 6F,72
0278:  DATA 74,69
027A:  DATA 65,2C
027C:  DATA 56,49
027E:  DATA 44,45
0280:  DATA 53,2C
0282:  DATA 43,6F
0284:  DATA 6D,70
0286:  DATA 74,65
0288:  DATA 72,2C
028A:  DATA 54,65
028C:  DATA 6D,70
028E:  DATA 73,20
0290:  DATA 64,27
0292:  DATA 61,74
0294:  DATA 74,65
0296:  DATA 6E,74
0298:  DATA 65,2C
029A:  DATA 00,00
029C:  CLRF   FF7
029E:  ADDLW  AC
02A0:  MOVWF  FF6
02A2:  MOVLW  02
02A4:  ADDWFC FF7,F
02A6:  TBLRD*+
02A8:  MOVF   FF5,W
02AA:  RETURN 0
02AC:  DATA 44,65
02AE:  DATA 73,69
02B0:  DATA 6E,66
02B2:  DATA 65,6B
02B4:  DATA 74,69
02B6:  DATA 6F,6E
02B8:  DATA 2E,2E
02BA:  DATA 2E,2C
02BC:  DATA 53,70
02BE:  DATA 65,69
02C0:  DATA 63,68
02C2:  DATA 65,72
02C4:  DATA 2C,5A
02C6:  DATA 65,69
02C8:  DATA 74,2C
02CA:  DATA 4D,69
02CC:  DATA 74,74
02CE:  DATA 65,2C
02D0:  DATA 47,65
02D2:  DATA 73,70
02D4:  DATA 65,69
02D6:  DATA 63,68
02D8:  DATA 65,72
02DA:  DATA 74,2C
02DC:  DATA 5A,65
02DE:  DATA 69,74
02E0:  DATA 65,69
02E2:  DATA 6E,73
02E4:  DATA 74,65
02E6:  DATA 6C,6C
02E8:  DATA 75,6E
02EA:  DATA 67,2C
02EC:  DATA 48,61
02EE:  DATA 72,64
02F0:  DATA 77,61
02F2:  DATA 72,65
02F4:  DATA 73,74
02F6:  DATA 65,75
02F8:  DATA 65,72
02FA:  DATA 75,6E
02FC:  DATA 67,2C
02FE:  DATA 57,61
0300:  DATA 68,6C
0302:  DATA 65,20
0304:  DATA 64,69
0306:  DATA 65,20
0308:  DATA 53,70
030A:  DATA 72,61
030C:  DATA 63,68
030E:  DATA 65,2C
0310:  DATA 41,75
0312:  DATA 73,66
0314:  DATA 61,68
0316:  DATA 72,74
0318:  DATA 2C,4C
031A:  DATA 45,45
031C:  DATA 52,2C
031E:  DATA 41,6E
0320:  DATA 7A,61
0322:  DATA 68,6C
0324:  DATA 2C,57
0326:  DATA 61,72
0328:  DATA 74,65
032A:  DATA 7A,65
032C:  DATA 69,74
032E:  DATA 2C,00
0330:  CLRF   FF7
0332:  ADDLW  40
0334:  MOVWF  FF6
0336:  MOVLW  03
0338:  ADDWFC FF7,F
033A:  TBLRD*+
033C:  MOVF   FF5,W
033E:  RETURN 0
0340:  DATA 44,69
0342:  DATA 73,69
0344:  DATA 6E,66
0346:  DATA 65,63
0348:  DATA 74,69
034A:  DATA 6F,6E
034C:  DATA 2E,2E
034E:  DATA 2E,2C
0350:  DATA 53,74
0352:  DATA 6F,72
0354:  DATA 65,2C
0356:  DATA 54,69
0358:  DATA 6D,65
035A:  DATA 2C,4D
035C:  DATA 69,64
035E:  DATA 64,6C
0360:  DATA 65,2C
0362:  DATA 53,61
0364:  DATA 76,65
0366:  DATA 64,2C
0368:  DATA 54,69
036A:  DATA 6D,65
036C:  DATA 20,53
036E:  DATA 65,74
0370:  DATA 74,69
0372:  DATA 6E,67
0374:  DATA 2C,48
0376:  DATA 61,72
0378:  DATA 64,77
037A:  DATA 61,72
037C:  DATA 65,20
037E:  DATA 43,6F
0380:  DATA 6E,74
0382:  DATA 72,6F
0384:  DATA 6C,2C
0386:  DATA 43,68
0388:  DATA 6F,6F
038A:  DATA 73,65
038C:  DATA 20,4C
038E:  DATA 61,6E
0390:  DATA 67,75
0392:  DATA 61,67
0394:  DATA 65,2C
0396:  DATA 45,78
0398:  DATA 69,74
039A:  DATA 2C,45
039C:  DATA 4D,50
039E:  DATA 54,59
03A0:  DATA 2C,43
03A2:  DATA 6F,75
03A4:  DATA 6E,74
03A6:  DATA 2C,53
03A8:  DATA 74,61
03AA:  DATA 6E,64
03AC:  DATA 62,79
03AE:  DATA 20,54
03B0:  DATA 69,6D
03B2:  DATA 65,2C
03B4:  DATA 00,00
03B6:  CLRF   FF7
03B8:  ADDLW  C6
03BA:  MOVWF  FF6
03BC:  MOVLW  03
03BE:  ADDWFC FF7,F
03C0:  TBLRD*+
03C2:  MOVF   FF5,W
03C4:  RETURN 0
03C6:  DATA 28,0C
03C8:  DATA 01,06
*
03E8:  DATA 0C,52
03EA:  DATA 4F,4C
03EC:  DATA 45,3A
03EE:  DATA 00,00
03F0:  DATA 0A,3C
03F2:  DATA 3C,3C
03F4:  DATA 20,20
03F6:  DATA 20,20
03F8:  DATA 3C,3E
03FA:  DATA 20,20
03FC:  DATA 20,20
03FE:  DATA 3E,3E
0400:  DATA 3E,00
0402:  DATA 0C,53
0404:  DATA 45,56
0406:  DATA 49,59
0408:  DATA 45,3A
040A:  DATA 00,00
040C:  DATA 0A,3C
040E:  DATA 3C,3C
0410:  DATA 20,20
0412:  DATA 20,20
0414:  DATA 3C,3E
0416:  DATA 20,20
0418:  DATA 20,20
041A:  DATA 3E,3E
041C:  DATA 3E,00
041E:  DATA 0A,25
0420:  DATA 73,3A
0422:  DATA 4D,49
0424:  DATA 4E,2D
0426:  DATA 32,35
0428:  DATA 00,00
042A:  DATA 0A,25
042C:  DATA 73,3A
042E:  DATA 25,73
0430:  DATA 2D,35
0432:  DATA 30,00
0434:  DATA 0A,25
0436:  DATA 73,3A
0438:  DATA 4D,41
043A:  DATA 58,2D
043C:  DATA 31,30
043E:  DATA 30,00
0440:  DATA 0C,44
0442:  DATA 55,52
0444:  DATA 20,4C
0446:  DATA 45,44
0448:  DATA 3A,00
044A:  DATA 0A,3C
044C:  DATA 3C,3C
044E:  DATA 20,20
0450:  DATA 20,20
0452:  DATA 3C,3E
0454:  DATA 20,20
0456:  DATA 20,20
0458:  DATA 3E,3E
045A:  DATA 3E,00
045C:  DATA 0C,47
045E:  DATA 45,43
0460:  DATA 20,4C
0462:  DATA 45,44
0464:  DATA 3A,00
0466:  DATA 0A,3C
0468:  DATA 3C,3C
046A:  DATA 20,20
046C:  DATA 20,20
046E:  DATA 3C,3E
0470:  DATA 20,20
0472:  DATA 20,20
0474:  DATA 3E,3E
0476:  DATA 3E,00
0478:  DATA 0C,47
047A:  DATA 45,43
047C:  DATA 49,53
047E:  DATA 20,53
0480:  DATA 45,4E
0482:  DATA 53,2E
0484:  DATA 3A,00
0486:  DATA 0A,3C
0488:  DATA 3C,3C
048A:  DATA 20,20
048C:  DATA 20,20
048E:  DATA 3C,3E
0490:  DATA 20,20
0492:  DATA 20,20
0494:  DATA 3E,3E
0496:  DATA 3E,00
0498:  DATA 0C,47
049A:  DATA 45,43
049C:  DATA 49,53
049E:  DATA 20,53
04A0:  DATA 45,4E
04A2:  DATA 53,2E
04A4:  DATA 3A,00
04A6:  DATA 0A,47
04A8:  DATA 45,43
04AA:  DATA 20,31
04AC:  DATA 00,00
04AE:  DATA 0C,47
04B0:  DATA 45,43
04B2:  DATA 49,53
04B4:  DATA 20,53
04B6:  DATA 45,4E
04B8:  DATA 53,2E
04BA:  DATA 3A,00
04BC:  DATA 0A,47
04BE:  DATA 45,43
04C0:  DATA 20,32
04C2:  DATA 00,00
04C4:  DATA 0C,4D
04C6:  DATA 4F,54
04C8:  DATA 4F,52
04CA:  DATA 3A,00
04CC:  DATA 0A,3C
04CE:  DATA 3C,3C
04D0:  DATA 20,20
04D2:  DATA 20,20
04D4:  DATA 3C,3E
04D6:  DATA 20,20
04D8:  DATA 20,20
04DA:  DATA 3E,3E
04DC:  DATA 3E,00
04DE:  DATA 0C,0A
04E0:  DATA 64,75
04E2:  DATA 74,79
04E4:  DATA 3A,25
04E6:  DATA 4C,75
04E8:  DATA 20,20
04EA:  DATA 20,00
04EC:  DATA 0C,0A
04EE:  DATA 64,75
04F0:  DATA 74,79
04F2:  DATA 3A,25
04F4:  DATA 4C,75
04F6:  DATA 20,20
04F8:  DATA 20,00
04FA:  DATA 0C,25
04FC:  DATA 73,3D
04FE:  DATA 25,75
0500:  DATA 20,53
0502:  DATA 0A,00
0504:  DATA 0A,3C
0506:  DATA 3C,3C
0508:  DATA 20,20
050A:  DATA 20,20
050C:  DATA 3C,3E
050E:  DATA 20,20
0510:  DATA 20,20
0512:  DATA 3E,3E
0514:  DATA 3E,00
0516:  DATA 0C,25
0518:  DATA 73,3D
051A:  DATA 25,75
051C:  DATA 20,53
051E:  DATA 0A,00
0520:  DATA 0A,3C
0522:  DATA 3C,3C
0524:  DATA 20,20
0526:  DATA 20,20
0528:  DATA 3C,3E
052A:  DATA 20,20
052C:  DATA 20,20
052E:  DATA 3E,3E
0530:  DATA 3E,00
0532:  DATA 0C,25
0534:  DATA 73,3D
0536:  DATA 25,75
0538:  DATA 20,53
053A:  DATA 0A,00
053C:  DATA 0A,3C
053E:  DATA 3C,3C
0540:  DATA 20,20
0542:  DATA 20,20
0544:  DATA 3C,3E
0546:  DATA 20,20
0548:  DATA 20,20
054A:  DATA 3E,3E
054C:  DATA 3E,00
054E:  DATA 0C,25
0550:  DATA 73,3D
0552:  DATA 25,75
0554:  DATA 20,53
0556:  DATA 0A,00
0558:  DATA 0A,3C
055A:  DATA 3C,3C
055C:  DATA 20,20
055E:  DATA 20,20
0560:  DATA 3C,3E
0562:  DATA 20,20
0564:  DATA 20,20
0566:  DATA 3E,3E
0568:  DATA 3E,00
056A:  DATA 0C,25
056C:  DATA 73,3D
056E:  DATA 25,75
0570:  DATA 20,53
0572:  DATA 0A,00
0574:  DATA 0A,3C
0576:  DATA 3C,3C
0578:  DATA 20,20
057A:  DATA 20,20
057C:  DATA 3C,3E
057E:  DATA 20,20
0580:  DATA 20,20
0582:  DATA 3E,3E
0584:  DATA 3E,00
0586:  DATA 0C,25
0588:  DATA 73,3D
058A:  DATA 25,4C
058C:  DATA 75,20
058E:  DATA 6D,53
0590:  DATA 0A,00
0592:  DATA 0A,3C
0594:  DATA 3C,3C
0596:  DATA 20,20
0598:  DATA 20,20
059A:  DATA 3C,3E
059C:  DATA 20,20
059E:  DATA 20,20
05A0:  DATA 3E,3E
05A2:  DATA 3E,00
05A4:  DATA 0A,3C
05A6:  DATA 3C,3C
05A8:  DATA 20,20
05AA:  DATA 20,20
05AC:  DATA 3C,3E
05AE:  DATA 20,20
05B0:  DATA 20,20
05B2:  DATA 3E,3E
05B4:  DATA 3E,00
05B6:  DATA 0A,3C
05B8:  DATA 3C,3C
05BA:  DATA 20,20
05BC:  DATA 20,20
05BE:  DATA 3C,3E
05C0:  DATA 20,20
05C2:  DATA 20,20
05C4:  DATA 3E,3E
05C6:  DATA 3E,00
05C8:  DATA 0C,21
05CA:  DATA 21,25
05CC:  DATA 73,21
05CE:  DATA 21,00
05D0:  DATA 0C,20
05D2:  DATA 20,20
05D4:  DATA 20,20
05D6:  DATA 20,4D
05D8:  DATA 45,4E
05DA:  DATA 55,00
05DC:  DATA 0A,3C
05DE:  DATA 3C,3C
05E0:  DATA 20,20
05E2:  DATA 20,20
05E4:  DATA 3C,3E
05E6:  DATA 20,20
05E8:  DATA 20,20
05EA:  DATA 3E,3E
05EC:  DATA 3E,00
05EE:  DATA 0A,3C
05F0:  DATA 3C,3C
05F2:  DATA 20,20
05F4:  DATA 20,20
05F6:  DATA 3C,3E
05F8:  DATA 20,20
05FA:  DATA 20,20
05FC:  DATA 3E,3E
05FE:  DATA 3E,00
0600:  DATA 0A,3C
0602:  DATA 3C,3C
0604:  DATA 20,20
0606:  DATA 20,20
0608:  DATA 3C,3E
060A:  DATA 20,20
060C:  DATA 20,20
060E:  DATA 3E,3E
0610:  DATA 3E,00
0612:  DATA 0A,3C
0614:  DATA 3C,3C
0616:  DATA 20,20
0618:  DATA 20,20
061A:  DATA 3C,3E
061C:  DATA 20,20
061E:  DATA 20,20
0620:  DATA 3E,3E
0622:  DATA 3E,00
0624:  DATA 0A,3C
0626:  DATA 3C,3C
0628:  DATA 20,20
062A:  DATA 20,20
062C:  DATA 3C,3E
062E:  DATA 20,20
0630:  DATA 20,20
0632:  DATA 3E,3E
0634:  DATA 3E,00
0636:  DATA 56,41
0638:  DATA 4C,46
063A:  DATA 20,53
063C:  DATA 55,52
063E:  DATA 45,00
0640:  DATA 0A,3C
0642:  DATA 3C,3C
0644:  DATA 20,20
0646:  DATA 20,20
0648:  DATA 3C,3E
064A:  DATA 20,20
064C:  DATA 20,20
064E:  DATA 3E,3E
0650:  DATA 3E,00
0652:  DATA 0A,3C
0654:  DATA 3C,3C
0656:  DATA 20,20
0658:  DATA 20,20
065A:  DATA 3C,3E
065C:  DATA 20,20
065E:  DATA 20,20
0660:  DATA 3E,3E
0662:  DATA 3E,00
0664:  DATA 0C,20
0666:  DATA 20,2E
0668:  DATA 2E,4C
066A:  DATA 59,53
066C:  DATA 2D,32
066E:  DATA 30,32
0670:  DATA 30,2E
0672:  DATA 2E,00
0674:  DATA 0A,20
0676:  DATA 20,5F
0678:  DATA 5F,59
067A:  DATA 4F,59
067C:  DATA 55,4E
067E:  DATA 43,41
0680:  DATA 4B,5F
0682:  DATA 5F,00
0684:  DATA 0A,25
0686:  DATA 73,3A
0688:  DATA 20,3F
068A:  DATA 3F,3F
068C:  DATA 00,00
068E:  DATA 0A,53
0690:  DATA 45,4E
0692:  DATA 53,3A
0694:  DATA 25,6C
0696:  DATA 75,00
0698:  DATA 0A,25
069A:  DATA 73,3A
069C:  DATA 4D,49
069E:  DATA 4E,2D
06A0:  DATA 32,35
06A2:  DATA 00,00
06A4:  DATA 0A,25
06A6:  DATA 73,3A
06A8:  DATA 25,73
06AA:  DATA 2D,35
06AC:  DATA 30,00
06AE:  DATA 0A,25
06B0:  DATA 73,3A
06B2:  DATA 4D,41
06B4:  DATA 58,2D
06B6:  DATA 31,30
06B8:  DATA 30,00
*
089C:  TBLRD*+
089E:  MOVF   FF5,F
08A0:  BZ    08BA
08A2:  MOVFF  FF6,193
08A6:  MOVFF  FF7,194
08AA:  MOVFF  FF5,196
08AE:  RCALL  0842
08B0:  MOVFF  193,FF6
08B4:  MOVFF  194,FF7
08B8:  BRA    089C
08BA:  RETURN 0
08BC:  MOVLB  1
08BE:  MOVF   x98,W
08C0:  ANDLW  07
08C2:  MOVWF  00
08C4:  RRCF   x98,W
08C6:  MOVWF  01
08C8:  RRCF   01,F
08CA:  RRCF   01,F
08CC:  MOVLW  1F
08CE:  ANDWF  01,F
08D0:  MOVF   01,W
08D2:  ADDWF  x9A,W
08D4:  MOVWF  FE9
08D6:  MOVLW  00
08D8:  ADDWFC x9B,W
08DA:  MOVWF  FEA
08DC:  CLRF   01
08DE:  INCF   01,F
08E0:  INCF   00,F
08E2:  BRA    08E6
08E4:  RLCF   01,F
08E6:  DECFSZ 00,F
08E8:  BRA    08E4
08EA:  MOVF   x99,F
08EC:  BZ    08F4
08EE:  MOVF   01,W
08F0:  IORWF  FEF,F
08F2:  BRA    08FA
08F4:  COMF   01,F
08F6:  MOVF   01,W
08F8:  ANDWF  FEF,F
08FA:  MOVLB  0
08FC:  RETURN 0
*
0EA0:  MOVF   FEF,F
0EA2:  BZ    0EC2
0EA4:  MOVFF  FEA,194
0EA8:  MOVFF  FE9,193
0EAC:  MOVFF  FEF,196
0EB0:  RCALL  0842
0EB2:  MOVFF  194,FEA
0EB6:  MOVFF  193,FE9
0EBA:  INCF   FE9,F
0EBC:  BTFSC  FD8.2
0EBE:  INCF   FEA,F
0EC0:  BRA    0EA0
0EC2:  RETURN 0
0EC4:  BTFSC  FD8.1
0EC6:  BRA    0ED0
0EC8:  MOVLW  01
0ECA:  MOVWF  FEA
0ECC:  MOVLW  81
0ECE:  MOVWF  FE9
0ED0:  CLRF   00
0ED2:  CLRF   01
0ED4:  CLRF   02
0ED6:  CLRF   03
0ED8:  MOVLB  1
0EDA:  CLRF   x81
0EDC:  CLRF   x82
0EDE:  CLRF   x83
0EE0:  CLRF   x84
0EE2:  MOVF   x80,W
0EE4:  IORWF  x7F,W
0EE6:  IORWF  x7E,W
0EE8:  IORWF  x7D,W
0EEA:  BZ    0F44
0EEC:  MOVLW  20
0EEE:  MOVWF  x85
0EF0:  BCF    FD8.0
0EF2:  RLCF   x79,F
0EF4:  RLCF   x7A,F
0EF6:  RLCF   x7B,F
0EF8:  RLCF   x7C,F
0EFA:  RLCF   x81,F
0EFC:  RLCF   x82,F
0EFE:  RLCF   x83,F
0F00:  RLCF   x84,F
0F02:  MOVF   x80,W
0F04:  SUBWF  x84,W
0F06:  BNZ   0F18
0F08:  MOVF   x7F,W
0F0A:  SUBWF  x83,W
0F0C:  BNZ   0F18
0F0E:  MOVF   x7E,W
0F10:  SUBWF  x82,W
0F12:  BNZ   0F18
0F14:  MOVF   x7D,W
0F16:  SUBWF  x81,W
0F18:  BNC   0F38
0F1A:  MOVF   x7D,W
0F1C:  SUBWF  x81,F
0F1E:  MOVF   x7E,W
0F20:  BTFSS  FD8.0
0F22:  INCFSZ x7E,W
0F24:  SUBWF  x82,F
0F26:  MOVF   x7F,W
0F28:  BTFSS  FD8.0
0F2A:  INCFSZ x7F,W
0F2C:  SUBWF  x83,F
0F2E:  MOVF   x80,W
0F30:  BTFSS  FD8.0
0F32:  INCFSZ x80,W
0F34:  SUBWF  x84,F
0F36:  BSF    FD8.0
0F38:  RLCF   00,F
0F3A:  RLCF   01,F
0F3C:  RLCF   02,F
0F3E:  RLCF   03,F
0F40:  DECFSZ x85,F
0F42:  BRA    0EF0
0F44:  MOVFF  181,FEF
0F48:  MOVFF  182,FEC
0F4C:  MOVFF  183,FEC
0F50:  MOVFF  184,FEC
0F54:  MOVLB  0
0F56:  RETURN 0
0F58:  MOVF   FE9,W
0F5A:  MOVLB  1
0F5C:  MOVWF  x71
0F5E:  MOVLW  3B
0F60:  MOVWF  x78
0F62:  MOVLW  9A
0F64:  MOVWF  x77
0F66:  MOVLW  CA
0F68:  MOVWF  x76
0F6A:  CLRF   x75
0F6C:  MOVLW  0A
0F6E:  MOVWF  x73
0F70:  BSF    FD8.1
0F72:  MOVLW  01
0F74:  MOVWF  FEA
0F76:  MOVLW  6D
0F78:  MOVWF  FE9
0F7A:  MOVFF  170,17C
0F7E:  MOVFF  16F,17B
0F82:  MOVFF  16E,17A
0F86:  MOVFF  16D,179
0F8A:  MOVFF  178,180
0F8E:  MOVFF  177,17F
0F92:  MOVFF  176,17E
0F96:  MOVFF  175,17D
0F9A:  MOVLB  0
0F9C:  RCALL  0EC4
0F9E:  MOVF   01,W
0FA0:  MOVF   00,F
0FA2:  BNZ   0FCA
0FA4:  MOVLB  1
0FA6:  MOVF   x73,W
0FA8:  XORLW  01
0FAA:  BTFSS  FD8.2
0FAC:  BRA    0FB2
0FAE:  MOVLB  0
0FB0:  BRA    0FCA
0FB2:  MOVF   x71,W
0FB4:  BZ    0FCE
0FB6:  ANDLW  0F
0FB8:  SUBWF  x73,W
0FBA:  BZ    0FBE
0FBC:  BC    0FDC
0FBE:  BTFSC  x71.7
0FC0:  BRA    0FDC
0FC2:  BTFSC  x71.6
0FC4:  BRA    0FCE
0FC6:  MOVLW  20
0FC8:  BRA    0FD0
0FCA:  MOVLB  1
0FCC:  CLRF   x71
0FCE:  MOVLW  30
0FD0:  ADDWF  00,F
0FD2:  MOVFF  00,196
0FD6:  MOVLB  0
0FD8:  RCALL  0842
0FDA:  MOVLB  1
0FDC:  BCF    FD8.1
0FDE:  MOVFF  178,17C
0FE2:  MOVFF  177,17B
0FE6:  MOVFF  176,17A
0FEA:  MOVFF  175,179
0FEE:  CLRF   x80
0FF0:  CLRF   x7F
0FF2:  CLRF   x7E
0FF4:  MOVLW  0A
0FF6:  MOVWF  x7D
0FF8:  MOVLB  0
0FFA:  RCALL  0EC4
0FFC:  MOVFF  03,178
1000:  MOVFF  02,177
1004:  MOVFF  01,176
1008:  MOVFF  00,175
100C:  MOVLB  1
100E:  DECFSZ x73,F
1010:  BRA    0F70
1012:  MOVLB  0
1014:  RETURN 0
1016:  TBLRD*+
1018:  MOVFF  FF6,194
101C:  MOVFF  FF7,195
1020:  MOVFF  FF5,196
1024:  RCALL  0842
1026:  MOVFF  194,FF6
102A:  MOVFF  195,FF7
102E:  MOVLB  1
1030:  DECFSZ x93,F
1032:  BRA    1036
1034:  BRA    103A
1036:  MOVLB  0
1038:  BRA    1016
103A:  MOVLB  0
103C:  RETURN 0
103E:  MOVLB  1
1040:  CLRF   x75
1042:  CLRF   x76
1044:  MOVLW  01
1046:  MOVWF  x77
1048:  CLRF   FDA
104A:  CLRF   FD9
104C:  MOVWF  x7A
104E:  MOVLW  6D
1050:  MOVWF  x79
1052:  MOVLW  01
1054:  MOVWF  FEA
1056:  MOVLW  71
1058:  MOVWF  FE9
105A:  MOVFF  17A,FE2
105E:  MOVFF  179,FE1
1062:  MOVFF  177,178
1066:  BCF    FD8.0
1068:  MOVF   FE5,W
106A:  MULWF  FEE
106C:  MOVF   FF3,W
106E:  ADDWFC x75,F
1070:  MOVF   FF4,W
1072:  ADDWFC x76,F
1074:  DECFSZ x78,F
1076:  BRA    1066
1078:  MOVFF  175,FDE
107C:  MOVFF  176,175
1080:  CLRF   x76
1082:  BTFSC  FD8.0
1084:  INCF   x76,F
1086:  INCF   x79,F
1088:  BTFSC  FD8.2
108A:  INCF   x7A,F
108C:  INCF   x77,F
108E:  MOVF   x77,W
1090:  SUBLW  05
1092:  BNZ   1052
1094:  MOVLB  0
1096:  RETURN 0
1098:  MOVLB  1
109A:  MOVF   x6F,W
109C:  MULWF  x71
109E:  MOVFF  FF3,01
10A2:  MOVFF  FF4,00
10A6:  MULWF  x72
10A8:  MOVF   FF3,W
10AA:  ADDWF  00,F
10AC:  MOVF   x70,W
10AE:  MULWF  x71
10B0:  MOVF   FF3,W
10B2:  ADDWFC 00,W
10B4:  MOVWF  02
10B6:  MOVLB  0
10B8:  RETURN 0
*
1128:  MOVLB  1
112A:  MOVF   x72,W
112C:  CLRF   01
112E:  SUBWF  x71,W
1130:  BC    1138
1132:  MOVFF  171,00
1136:  BRA    1150
1138:  CLRF   00
113A:  MOVLW  08
113C:  MOVWF  x73
113E:  RLCF   x71,F
1140:  RLCF   00,F
1142:  MOVF   x72,W
1144:  SUBWF  00,W
1146:  BTFSC  FD8.0
1148:  MOVWF  00
114A:  RLCF   01,F
114C:  DECFSZ x73,F
114E:  BRA    113E
1150:  MOVLB  0
1152:  RETURN 0
1154:  MOVF   01,W
1156:  MOVFF  16F,171
115A:  MOVLW  64
115C:  MOVLB  1
115E:  MOVWF  x72
1160:  MOVLB  0
1162:  RCALL  1128
1164:  MOVFF  00,16F
1168:  MOVF   01,W
116A:  MOVLW  30
116C:  BNZ   117E
116E:  MOVLB  1
1170:  BTFSS  x70.1
1172:  BRA    1194
1174:  BTFSC  x70.3
1176:  BRA    1194
1178:  BTFSC  x70.4
117A:  MOVLW  20
117C:  BRA    1186
117E:  MOVLB  1
1180:  BCF    x70.3
1182:  BCF    x70.4
1184:  BSF    x70.0
1186:  ADDWF  01,F
1188:  MOVFF  01,196
118C:  MOVLB  0
118E:  CALL   0842
1192:  MOVLB  1
1194:  MOVFF  16F,171
1198:  MOVLW  0A
119A:  MOVWF  x72
119C:  MOVLB  0
119E:  RCALL  1128
11A0:  MOVFF  00,16F
11A4:  MOVF   01,W
11A6:  MOVLW  30
11A8:  BNZ   11BA
11AA:  MOVLB  1
11AC:  BTFSC  x70.3
11AE:  BRA    11C6
11B0:  BTFSS  x70.0
11B2:  BRA    11C6
11B4:  BTFSC  x70.4
11B6:  MOVLW  20
11B8:  MOVLB  0
11BA:  ADDWF  01,F
11BC:  MOVFF  01,196
11C0:  CALL   0842
11C4:  MOVLB  1
11C6:  MOVLW  30
11C8:  ADDWF  x6F,F
11CA:  MOVFF  16F,196
11CE:  MOVLB  0
11D0:  CALL   0842
11D4:  RETURN 0
*
15DA:  MOVFF  FEA,179
15DE:  MOVFF  FE9,178
15E2:  MOVLB  1
15E4:  SWAPF  x72,W
15E6:  IORLW  F0
15E8:  MOVWF  x74
15EA:  ADDWF  x74,F
15EC:  ADDLW  E2
15EE:  MOVWF  x75
15F0:  ADDLW  32
15F2:  MOVWF  x77
15F4:  MOVF   x72,W
15F6:  ANDLW  0F
15F8:  ADDWF  x75,F
15FA:  ADDWF  x75,F
15FC:  ADDWF  x77,F
15FE:  ADDLW  E9
1600:  MOVWF  x76
1602:  ADDWF  x76,F
1604:  ADDWF  x76,F
1606:  SWAPF  x71,W
1608:  ANDLW  0F
160A:  ADDWF  x76,F
160C:  ADDWF  x77,F
160E:  RLCF   x76,F
1610:  RLCF   x77,F
1612:  COMF   x77,F
1614:  RLCF   x77,F
1616:  MOVF   x71,W
1618:  ANDLW  0F
161A:  ADDWF  x77,F
161C:  RLCF   x74,F
161E:  MOVLW  07
1620:  MOVWF  x73
1622:  MOVLW  0A
1624:  DECF   x76,F
1626:  ADDWF  x77,F
1628:  BNC   1624
162A:  DECF   x75,F
162C:  ADDWF  x76,F
162E:  BNC   162A
1630:  DECF   x74,F
1632:  ADDWF  x75,F
1634:  BNC   1630
1636:  DECF   x73,F
1638:  ADDWF  x74,F
163A:  BNC   1636
163C:  MOVLW  01
163E:  MOVWF  FEA
1640:  MOVLW  73
1642:  MOVWF  FE9
1644:  MOVLW  07
1646:  ANDWF  x78,W
1648:  BCF    x78.6
164A:  ADDWF  FE9,F
164C:  MOVLW  00
164E:  ADDWFC FEA,F
1650:  MOVF   FE9,W
1652:  SUBLW  77
1654:  BNZ   165C
1656:  DECFSZ FEA,W
1658:  BRA    165C
165A:  BSF    x78.6
165C:  MOVF   FEF,W
165E:  MOVWF  00
1660:  BNZ   1672
1662:  BTFSC  x78.6
1664:  BRA    1672
1666:  BTFSC  x78.4
1668:  BRA    1696
166A:  BTFSC  x78.3
166C:  BRA    1672
166E:  MOVLW  20
1670:  BRA    1678
1672:  BSF    x78.3
1674:  BCF    x78.4
1676:  MOVLW  30
1678:  ADDWF  00,F
167A:  MOVFF  FEA,172
167E:  MOVFF  FE9,171
1682:  MOVFF  00,196
1686:  MOVLB  0
1688:  CALL   0842
168C:  MOVFF  172,FEA
1690:  MOVFF  171,FE9
1694:  MOVLB  1
1696:  MOVF   FEE,W
1698:  BTFSS  x78.6
169A:  BRA    1650
169C:  MOVLB  0
169E:  RETURN 0
*
1DF2:  ADDWF  FE8,W
1DF4:  CLRF   FF7
1DF6:  RLCF   FF7,F
1DF8:  ADDLW  0D
1DFA:  MOVWF  FF6
1DFC:  MOVLW  1E
1DFE:  ADDWFC FF7,F
1E00:  TBLRD*-
1E02:  MOVF   FF5,W
1E04:  MOVWF  FFA
1E06:  TBLRD*
1E08:  MOVF   FF5,W
1E0A:  MOVWF  FF9
1E0C:  DATA B4,16
1E0E:  DATA 5E,17
1E10:  DATA 2A,1A
1E12:  DATA C8,1A
1E14:  DATA 66,1B
1E16:  DATA 68,1C
....................  
.................... #list 
....................  
....................     #device adc=10 
....................     #device HIGH_INTS=TRUE  
....................     #device PASS_STRINGS=IN_RAM   
....................  
....................     #FUSES NOWDT                    //No Watch Dog Timer 
....................     #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
....................     #FUSES INTRC_IO                 //Internal RC Osc, no CLKOUT 
....................     #FUSES PLLEN                  //4X HW PLL disabled, 4X PLL enabled in software 
....................     #FUSES NOPUT                      //Power Up Timer 
....................     #FUSES NOBROWNOUT               //No brownout reset 
....................     #FUSES WDT_SW                   //No Watch Dog Timer, enabled in Software 
....................     #FUSES NOPBADEN                 //PORTB pins are configured as digital I/O on RESET 
....................     #FUSES MCLR                   //Master Clear pin used for I/O 
....................     #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................     #FUSES PROTECT                  //Code protected from reads 
....................     //#FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................     #FUSES NOFCMEN 
....................     #FUSES NOHFOFST      
....................  
....................     #use delay(internal=64MHz) // çalýþtý 4MHZ çaýþtý 
*
06CE:  MOVLW  01
06D0:  MOVWF  FEA
06D2:  MOVLW  99
06D4:  MOVWF  FE9
06D6:  MOVF   FEF,W
06D8:  BZ    06F6
06DA:  MOVLW  14
06DC:  MOVWF  01
06DE:  CLRF   00
06E0:  DECFSZ 00,F
06E2:  BRA    06E0
06E4:  DECFSZ 01,F
06E6:  BRA    06DE
06E8:  MOVLW  BF
06EA:  MOVWF  00
06EC:  DECFSZ 00,F
06EE:  BRA    06EC
06F0:  BRA    06F2
06F2:  DECFSZ FEF,F
06F4:  BRA    06DA
06F6:  RETURN 0
*
0742:  MOVLW  01
0744:  MOVLB  1
0746:  SUBWF  x9D,F
0748:  BNC   0762
074A:  MOVLW  01
074C:  MOVWF  FEA
074E:  MOVLW  9D
0750:  MOVWF  FE9
0752:  MOVF   FEF,W
0754:  BZ    0762
0756:  MOVLW  04
0758:  MOVWF  00
075A:  DECFSZ 00,F
075C:  BRA    075A
075E:  DECFSZ FEF,F
0760:  BRA    0756
0762:  MOVLB  0
0764:  GOTO   0776 (RETURN)
....................  
....................      //#use rs232(baud=9600,parity=N,UART1,bits=8,stream=RFID_serial)  //uart1 
....................    // #use rs232(baud=9600,parity=N,UART2,bits=8,stream=PORT2)  
....................      
....................       extern unsigned int32 timerIntSay; 
....................    
....................       const char lcd_diller[]={"TURKCE,FRANCAIS,Deutsch,English,"}; 
....................                                                                                                                //11  12 
....................       const char lcd_tr[]={"OTO DEZENFEKTE,Depo,Sure,Orta,Kaydedildi,Sure Ayar,DONANIM KONT.,DIL SEC,CIKIS,BOS,Sayac,Bekleme Suresi,"}; 
....................       //#define lcd_tr "OTO DEZENFEKTE,Depo,Sure,Orta,Kaydedildi,Sure Ayar,DONANIM KONT.,DIL SEC,CIKIS,BOS," 
....................       const char lcd_fr[]={"Desinfection...,Reservoir,Temps,Milieu,Enregistre,Reglages temps,Cont. materiel,choisissez lang.,Sortie,VIDES,Compter,Temps d'attente,"}; 
....................       const char lcd_alm[]={"Desinfektion...,Speicher,Zeit,Mitte,Gespeichert,Zeiteinstellung,Hardwaresteuerung,Wahle die Sprache,Ausfahrt,LEER,Anzahl,Wartezeit,"}; 
....................       const char lcd_ing[]={"Disinfection...,Store,Time,Middle,Saved,Time Setting,Hardware Control,Choose Language,Exit,EMPTY,Count,Standby Time,"}; 
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* MAIN_OTO_DEZ_KONT_H */ 
....................  
....................  
.................... //#include <stdio.h> 
.................... #include <C:\Program Files (x86)\PICC\Drivers\stdlib.h> //rand vb ,için  tam yolu yazmak dosyayý açamama hatasýný giderdi 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0A14:  MOVFF  239,23D
0A18:  MOVFF  238,23C
0A1C:  MOVFF  23D,03
0A20:  MOVLB  2
0A22:  MOVFF  23C,FE9
0A26:  MOVFF  03,FEA
0A2A:  MOVF   FEF,F
0A2C:  BZ    0A86
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0A2E:  MOVFF  23B,23F
0A32:  MOVFF  23A,23E
0A36:  MOVFF  23F,03
0A3A:  MOVFF  23E,FE9
0A3E:  MOVFF  03,FEA
0A42:  MOVF   FEF,F
0A44:  BZ    0A7A
....................          if (*sc1 == *sc2) 
0A46:  MOVFF  23D,03
0A4A:  MOVFF  23C,FE9
0A4E:  MOVFF  03,FEA
0A52:  MOVFF  FEF,240
0A56:  MOVFF  23F,03
0A5A:  MOVFF  23E,FE9
0A5E:  MOVFF  03,FEA
0A62:  MOVF   FEF,W
0A64:  SUBWF  x40,W
0A66:  BNZ   0A72
....................             return(sc1); 
0A68:  MOVFF  23C,01
0A6C:  MOVFF  23D,02
0A70:  BRA    0A8C
0A72:  INCF   x3E,F
0A74:  BTFSC  FD8.2
0A76:  INCF   x3F,F
0A78:  BRA    0A36
0A7A:  INCF   x3C,F
0A7C:  BTFSC  FD8.2
0A7E:  INCF   x3D,F
0A80:  MOVLB  0
0A82:  BRA    0A1C
0A84:  MOVLB  2
....................    return(0); 
0A86:  MOVLW  00
0A88:  MOVWF  01
0A8A:  MOVWF  02
0A8C:  MOVLB  0
0A8E:  GOTO   0B36 (RETURN)
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0980:  MOVFF  239,23D
0984:  MOVFF  238,23C
0988:  MOVFF  23D,03
098C:  MOVLB  2
098E:  MOVFF  23C,FE9
0992:  MOVFF  03,FEA
0996:  MOVF   FEF,F
0998:  BZ    09FE
....................       for (sc2 = s2; ; sc2++) 
099A:  MOVFF  23B,23F
099E:  MOVFF  23A,23E
....................     if (*sc2 == '\0') 
09A2:  MOVFF  23F,03
09A6:  MOVFF  23E,FE9
09AA:  MOVFF  03,FEA
09AE:  MOVF   FEF,F
09B0:  BNZ   09C6
....................        return(sc1 - s1); 
09B2:  MOVF   x38,W
09B4:  SUBWF  x3C,W
09B6:  MOVWF  00
09B8:  MOVF   x39,W
09BA:  SUBWFB x3D,W
09BC:  MOVWF  03
09BE:  MOVFF  00,01
09C2:  BRA    0A0E
09C4:  BRA    09EA
....................          else if (*sc1 == *sc2) 
09C6:  MOVFF  23D,03
09CA:  MOVFF  23C,FE9
09CE:  MOVFF  03,FEA
09D2:  MOVFF  FEF,240
09D6:  MOVFF  23F,03
09DA:  MOVFF  23E,FE9
09DE:  MOVFF  03,FEA
09E2:  MOVF   FEF,W
09E4:  SUBWF  x40,W
09E6:  BNZ   09EA
....................             break; 
09E8:  BRA    09F2
09EA:  INCF   x3E,F
09EC:  BTFSC  FD8.2
09EE:  INCF   x3F,F
09F0:  BRA    09A2
09F2:  INCF   x3C,F
09F4:  BTFSC  FD8.2
09F6:  INCF   x3D,F
09F8:  MOVLB  0
09FA:  BRA    0988
09FC:  MOVLB  2
....................    return(sc1 - s1); 
09FE:  MOVF   x38,W
0A00:  SUBWF  x3C,W
0A02:  MOVWF  00
0A04:  MOVF   x39,W
0A06:  SUBWFB x3D,W
0A08:  MOVWF  03
0A0A:  MOVFF  00,01
0A0E:  MOVLB  0
0A10:  GOTO   0B00 (RETURN)
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0A92:  MOVFF  239,23B
0A96:  MOVFF  238,23A
0A9A:  MOVFF  23B,03
0A9E:  MOVLB  2
0AA0:  MOVFF  23A,FE9
0AA4:  MOVFF  03,FEA
0AA8:  MOVF   FEF,F
0AAA:  BZ    0AB8
0AAC:  INCF   x3A,F
0AAE:  BTFSC  FD8.2
0AB0:  INCF   x3B,F
0AB2:  MOVLB  0
0AB4:  BRA    0A9A
0AB6:  MOVLB  2
....................    return(sc - s); 
0AB8:  MOVF   x38,W
0ABA:  SUBWF  x3A,W
0ABC:  MOVWF  00
0ABE:  MOVF   x39,W
0AC0:  SUBWFB x3B,W
0AC2:  MOVWF  03
0AC4:  MOVFF  00,01
0AC8:  MOVWF  02
0ACA:  MOVLB  0
0ACC:  GOTO   0B72 (RETURN)
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
0AD0:  MOVLB  2
0AD2:  MOVF   x30,W
0AD4:  IORWF  x31,W
0AD6:  BZ    0AE0
0AD8:  MOVFF  231,03
0ADC:  MOVF   x30,W
0ADE:  BRA    0AE6
0AE0:  MOVFF  33,03
0AE4:  MOVF   32,W
0AE6:  MOVWF  x34
0AE8:  MOVFF  03,235
....................    beg += strspn(beg, s2); 
0AEC:  MOVFF  235,239
0AF0:  MOVFF  234,238
0AF4:  MOVFF  233,23B
0AF8:  MOVFF  232,23A
0AFC:  MOVLB  0
0AFE:  BRA    0980
0B00:  MOVF   01,W
0B02:  MOVLB  2
0B04:  ADDWF  x34,F
0B06:  MOVLW  00
0B08:  ADDWFC x35,F
....................    if (*beg == '\0') 
0B0A:  MOVFF  235,03
0B0E:  MOVFF  234,FE9
0B12:  MOVFF  03,FEA
0B16:  MOVF   FEF,F
0B18:  BNZ   0B22
....................       return(0); 
0B1A:  MOVLW  00
0B1C:  MOVWF  01
0B1E:  MOVWF  02
0B20:  BRA    0B88
....................        
....................    end = strpbrk(beg, s2); 
0B22:  MOVFF  235,239
0B26:  MOVFF  234,238
0B2A:  MOVFF  233,23B
0B2E:  MOVFF  232,23A
0B32:  MOVLB  0
0B34:  BRA    0A14
0B36:  MOVFF  02,237
0B3A:  MOVFF  01,236
....................    if (end != '\0') 
0B3E:  MOVLB  2
0B40:  MOVF   x36,F
0B42:  BNZ   0B48
0B44:  MOVF   x37,F
0B46:  BZ    0B66
....................    { 
....................       *end = '\0'; 
0B48:  MOVFF  237,03
0B4C:  MOVFF  236,FE9
0B50:  MOVFF  03,FEA
0B54:  CLRF   FEF
....................       end++; 
0B56:  INCF   x36,F
0B58:  BTFSC  FD8.2
0B5A:  INCF   x37,F
....................       save = end; 
0B5C:  MOVFF  237,33
0B60:  MOVFF  236,32
....................    } 
0B64:  BRA    0B80
....................    else 
....................       save = beg + strlen(beg); 
0B66:  MOVFF  235,239
0B6A:  MOVFF  234,238
0B6E:  MOVLB  0
0B70:  BRA    0A92
0B72:  MOVF   01,W
0B74:  MOVLB  2
0B76:  ADDWF  x34,W
0B78:  MOVWF  32
0B7A:  MOVF   02,W
0B7C:  ADDWFC x35,W
0B7E:  MOVWF  33
....................     
....................    return(beg); 
0B80:  MOVFF  234,01
0B84:  MOVFF  235,02
0B88:  MOVLB  0
0B8A:  GOTO   0BCA (RETURN)
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "timer.c" 
.................... #include "timer.h" 
.................... /*  
....................  * File:   timer.h 
....................  * Author: ilyas 
....................  * 
....................  * Created on 25 Aralýk 2018 Salý, 08:35 
....................  */ 
....................  
.................... #ifndef TIMER_H 
.................... #define	TIMER_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
....................     unsigned int32 timerIntSay=0; 
....................     unsigned long timer_m1_say=0; 
....................     unsigned long timer_m2_say=0; 
....................     unsigned long timer_m3_say=0; 
....................      
....................     #define millis() timerIntSay 
....................     #define setMillis(x) timerIntSay=x 
....................  
....................     void timer_kur(); 
....................     void Timer0_int(); 
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* TIMER_H */ 
....................  
....................  
.................... void timer_kur(){ 
....................      
....................     setup_timer_0(T0_INTERNAl | T0_8_BIT | T0_DIV_64);    //32 idi  
*
06BA:  MOVLW  C5
06BC:  MOVWF  FD5
....................     set_timer0(0x05); //1000uS 64MHZ  T0_DIV_64 ile 1mS   
06BE:  CLRF   FD7
06C0:  MOVLW  05
06C2:  MOVWF  FD6
....................                       //0x05, T0_8_BIT | T0_DIV_64 -> 500uS son hesapta, kontrol edilecek. uygulamada  
....................                       // 17.01.2020 : T0_8_BIT | T0_DIV_64 500uS çýkýyor. 
....................      
.................... //    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
.................... //    set_timer1(0xFB1D);   //64285 1000uS div_8 ile kesme    
.................... //    setup_timer_3(T3_INTERNAL|T3_DIV_BY_8); 
.................... //    set_timer3(0xFB1D); 
.................... //    clear_interrupt(INT_TIMER3); 
.................... //    enable_interrupts(INT_TIMER3);  
.................... //    disable_interrupts(INT_TIMER3); 
.................... //    enable_interrupts(PERIPH); 
.................... //    enable_interrupts(INT_TIMER1); 
....................      
....................     enable_interrupts(INT_TIMER0); 
06C4:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
06C6:  MOVLW  C0
06C8:  IORWF  FF2,F
06CA:  GOTO   29CA (RETURN)
....................       
.................... } 
.................... long say=0; 
.................... #INT_TIMER0 HIGH                    //Timer0 Kesmesi 
.................... void Timer0_int(){ 
....................     set_timer0(0x05); //1000uS 64MHZ 
*
03CA:  CLRF   FD7
03CC:  MOVLW  05
03CE:  MOVWF  FD6
....................  
....................     timerIntSay++; 
03D0:  MOVLW  01
03D2:  ADDWF  2E,F
03D4:  BTFSC  FD8.0
03D6:  INCF   2F,F
03D8:  BTFSC  FD8.2
03DA:  INCF   30,F
03DC:  BTFSC  FD8.2
03DE:  INCF   31,F
....................  
....................  
....................     clear_interrupt(INT_TIMER0 ) ; 
03E0:  BCF    FF2.2
.................... } 
....................  
.................... #include "timer.h" 
.................... /*  
....................  * File:   timer.h 
....................  * Author: ilyas 
....................  * 
....................  * Created on 25 Aralýk 2018 Salý, 08:35 
....................  */ 
....................  
.................... #ifndef TIMER_H 
.................... #define	TIMER_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................  
....................     unsigned int32 timerIntSay=0; 
....................     unsigned long timer_m1_say=0; 
....................     unsigned long timer_m2_say=0; 
....................     unsigned long timer_m3_say=0; 
....................      
....................     #define millis() timerIntSay 
....................     #define setMillis(x) timerIntSay=x 
....................  
....................     void timer_kur(); 
....................     void Timer0_int(); 
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* TIMER_H */ 
....................  
....................  
.................... #include "flex_lcd.c" 
.................... // flex_lcd.c  
....................  
.................... // These pins are for the Microchip PicDem2-Plus board,  
.................... // which is what I used to test the driver.  Change these  
.................... // pins to fit your own board.  
....................  
.................... #define LCD_DB4   PIN_D0  
.................... #define LCD_DB5   PIN_D1  
.................... #define LCD_DB6   PIN_D2  
.................... #define LCD_DB7   PIN_D3  
....................  
.................... #define LCD_E     PIN_D5  
.................... #define LCD_RS    PIN_D4  
.................... #define LCD_RW    PIN_A2  
....................  
.................... // If you only want a 6-pin interface to your LCD, then  
.................... // connect the R/W pin on the LCD to ground, and comment  
.................... // out the following line.  
....................  
.................... //#define USE_LCD_RW   0//1       
....................  
.................... //========================================  
....................  
.................... #define lcd_type 2        // 0=5x7, 1=5x10, 2=2 lines  
03E2:  BCF    FF2.2
03E4:  GOTO   010A
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line  
....................  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................     0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots  
....................     0xc,                    // Display on  
....................     1,                      // Clear display  
....................     6                       // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
....................     // Note:  !! converts an integer expression  
....................     // to a boolean (1 or 0).  
....................      output_bit(LCD_DB4, !!(nibble & 1));  
*
06F8:  MOVLB  1
06FA:  BTFSC  x9E.0
06FC:  BRA    0702
06FE:  BCF    F8C.0
0700:  BRA    0704
0702:  BSF    F8C.0
0704:  BCF    F95.0
....................      output_bit(LCD_DB5, !!(nibble & 2));   
0706:  BTFSC  x9E.1
0708:  BRA    070E
070A:  BCF    F8C.1
070C:  BRA    0710
070E:  BSF    F8C.1
0710:  BCF    F95.1
....................      output_bit(LCD_DB6, !!(nibble & 4));     
0712:  BTFSC  x9E.2
0714:  BRA    071A
0716:  BCF    F8C.2
0718:  BRA    071C
071A:  BSF    F8C.2
071C:  BCF    F95.2
....................      output_bit(LCD_DB7, !!(nibble & 8));     
071E:  BTFSC  x9E.3
0720:  BRA    0726
0722:  BCF    F8C.3
0724:  BRA    0728
0726:  BSF    F8C.3
0728:  BCF    F95.3
....................  
....................      delay_cycles(1);  
072A:  NOP   
....................      output_high(LCD_E);  
072C:  BCF    F95.5
072E:  BSF    F8C.5
....................      delay_us(2);  
0730:  MOVLW  0A
0732:  MOVWF  00
0734:  DECFSZ 00,F
0736:  BRA    0734
0738:  NOP   
....................      output_low(LCD_E);  
073A:  BCF    F95.5
073C:  BCF    F8C.5
073E:  MOVLB  0
0740:  RETURN 0
.................... }  
....................  
.................... //-----------------------------------  
.................... // This sub-routine is only called by lcd_read_byte().  
.................... // It's not a stand-alone routine.  For example, the  
.................... // R/W signal is set high by lcd_read_byte() before  
.................... // this routine is called.       
....................  
.................... #ifdef USE_LCD_RW  
....................     int8 lcd_read_nibble(void)  
....................     {  
....................         int8 retval;  
....................         // Create bit variables so that we can easily set  
....................         // individual bits in the retval variable.  
....................         #bit retval_0 = retval.0  
....................         #bit retval_1 = retval.1  
....................         #bit retval_2 = retval.2  
....................         #bit retval_3 = retval.3  
....................  
....................         retval = 0;  
....................  
....................         output_high(LCD_E);  
....................         delay_cycles(1);  
....................  
....................         retval_0 = input(LCD_DB4);  
....................         retval_1 = input(LCD_DB5);  
....................         retval_2 = input(LCD_DB6);  
....................         retval_3 = input(LCD_DB7);  
....................  
....................         output_low(LCD_E);  
....................  
....................         return(retval);     
....................     }     
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_LCD_RW  
....................     int8 lcd_read_byte(void)  
....................     {  
....................         int8 low;  
....................         int8 high;  
....................  
....................         output_high(LCD_RW);  
....................         delay_cycles(1);  
....................  
....................         high = lcd_read_nibble();  
....................  
....................         low = lcd_read_nibble();  
....................  
....................         return( (high<<4) | low);  
....................     }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
....................     output_low(LCD_RS);  
*
0768:  BCF    F95.4
076A:  BCF    F8C.4
....................  
....................     #ifdef USE_LCD_RW  
....................         while(bit_test(lcd_read_byte(),7)) ;  
....................     #else  
....................         delay_us(60);   
076C:  MOVLW  3C
076E:  MOVLB  1
0770:  MOVWF  x9D
0772:  MOVLB  0
0774:  BRA    0742
....................     #endif  
....................  
....................     if(address)  
0776:  MOVLB  1
0778:  MOVF   x9B,F
077A:  BZ    0782
....................        output_high(LCD_RS);  
077C:  BCF    F95.4
077E:  BSF    F8C.4
0780:  BRA    0786
....................     else  
....................        output_low(LCD_RS);  
0782:  BCF    F95.4
0784:  BCF    F8C.4
....................  
....................      delay_cycles(1);  
0786:  NOP   
....................  
....................     #ifdef USE_LCD_RW  
....................         output_low(LCD_RW);  
....................         delay_cycles(1);  
....................     #endif  
....................  
....................     output_low(LCD_E);  
0788:  BCF    F95.5
078A:  BCF    F8C.5
....................  
....................     lcd_send_nibble(n >> 4);  
078C:  SWAPF  x9C,W
078E:  MOVWF  x9D
0790:  MOVLW  0F
0792:  ANDWF  x9D,F
0794:  MOVFF  19D,19E
0798:  MOVLB  0
079A:  RCALL  06F8
....................     lcd_send_nibble(n & 0xf);  
079C:  MOVLB  1
079E:  MOVF   x9C,W
07A0:  ANDLW  0F
07A2:  MOVWF  x9D
07A4:  MOVWF  x9E
07A6:  MOVLB  0
07A8:  RCALL  06F8
07AA:  RETURN 0
.................... }  
....................  
.................... //----------------------------  
.................... void lcd_init(void)  
.................... {  
....................     int8 i;  
....................  
....................     output_low(LCD_RS);  
07AC:  BCF    F95.4
07AE:  BCF    F8C.4
....................  
....................     #ifdef USE_LCD_RW  
....................         output_low(LCD_RW);  
....................     #endif  
....................  
....................     output_low(LCD_E);  
07B0:  BCF    F95.5
07B2:  BCF    F8C.5
....................  
....................     delay_ms(15);  
07B4:  MOVLW  0F
07B6:  MOVLB  1
07B8:  MOVWF  x99
07BA:  MOVLB  0
07BC:  RCALL  06CE
....................  
....................     for(i=0 ;i < 3; i++)  
07BE:  MOVLB  1
07C0:  CLRF   x69
07C2:  MOVF   x69,W
07C4:  SUBLW  02
07C6:  BNC   07E0
....................     {  
....................         lcd_send_nibble(0x03);  
07C8:  MOVLW  03
07CA:  MOVWF  x9E
07CC:  MOVLB  0
07CE:  RCALL  06F8
....................         delay_ms(5);  
07D0:  MOVLW  05
07D2:  MOVLB  1
07D4:  MOVWF  x99
07D6:  MOVLB  0
07D8:  RCALL  06CE
07DA:  MOVLB  1
07DC:  INCF   x69,F
07DE:  BRA    07C2
....................     }  
....................  
....................     lcd_send_nibble(0x02);  
07E0:  MOVLW  02
07E2:  MOVWF  x9E
07E4:  MOVLB  0
07E6:  RCALL  06F8
....................  
....................     for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
07E8:  MOVLB  1
07EA:  CLRF   x69
07EC:  MOVF   x69,W
07EE:  SUBLW  03
07F0:  BNC   0816
....................        {  
....................         lcd_send_byte(0, LCD_INIT_STRING[i]);  
07F2:  CLRF   03
07F4:  MOVF   x69,W
07F6:  MOVLB  0
07F8:  RCALL  03B6
07FA:  MOVLB  1
07FC:  MOVWF  x6A
07FE:  CLRF   x9B
0800:  MOVWF  x9C
0802:  MOVLB  0
0804:  RCALL  0768
....................  
....................         // If the R/W signal is not used, then  
....................         // the busy bit can't be polled.  One of  
....................         // the init commands takes longer than  
....................         // the hard-coded delay of 60 us, so in  
....................         // that case, lets just do a 5 ms delay  
....................         // after all four of them.  
....................         #ifndef USE_LCD_RW  
....................             delay_ms(5);  
0806:  MOVLW  05
0808:  MOVLB  1
080A:  MOVWF  x99
080C:  MOVLB  0
080E:  RCALL  06CE
....................         #endif  
0810:  MOVLB  1
0812:  INCF   x69,F
0814:  BRA    07EC
....................        }  
0816:  MOVLB  0
0818:  GOTO   29D0 (RETURN)
....................  
.................... }  
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
....................     int8 address;  
....................  
....................     if(y != 1)  
081C:  MOVLB  1
081E:  DECFSZ x98,W
0820:  BRA    0824
0822:  BRA    082A
....................        address = lcd_line_two;  
0824:  MOVLW  40
0826:  MOVWF  x99
0828:  BRA    082C
....................     else  
....................        address=0;  
082A:  CLRF   x99
....................  
....................     address += x-1;  
082C:  MOVLW  01
082E:  SUBWF  x97,W
0830:  ADDWF  x99,F
....................     lcd_send_byte(0, 0x80 | address);  
0832:  MOVF   x99,W
0834:  IORLW  80
0836:  MOVWF  x9A
0838:  CLRF   x9B
083A:  MOVWF  x9C
083C:  MOVLB  0
083E:  RCALL  0768
0840:  RETURN 0
.................... }  
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................     switch(c)  
0842:  MOVLB  1
0844:  MOVF   x96,W
0846:  XORLW  0C
0848:  MOVLB  0
084A:  BZ    0856
084C:  XORLW  06
084E:  BZ    086E
0850:  XORLW  02
0852:  BZ    087E
0854:  BRA    088C
....................       {  
....................        case '\f':               //LCD temizle 
....................          lcd_send_byte(0,1);  
0856:  MOVLB  1
0858:  CLRF   x9B
085A:  MOVLW  01
085C:  MOVWF  x9C
085E:  MOVLB  0
0860:  RCALL  0768
....................          delay_ms(2);  
0862:  MOVLW  02
0864:  MOVLB  1
0866:  MOVWF  x99
0868:  MOVLB  0
086A:  RCALL  06CE
....................          break;  
086C:  BRA    089A
....................  
....................        case '\n':               //LCD ikinci satýra geçir 
....................           lcd_gotoxy(1,2);  
086E:  MOVLW  01
0870:  MOVLB  1
0872:  MOVWF  x97
0874:  MOVLW  02
0876:  MOVWF  x98
0878:  MOVLB  0
087A:  RCALL  081C
....................           break;  
087C:  BRA    089A
....................  
....................        case '\b':               //  Move back one position 
....................           lcd_send_byte(0,0x10);  
087E:  MOVLB  1
0880:  CLRF   x9B
0882:  MOVLW  10
0884:  MOVWF  x9C
0886:  MOVLB  0
0888:  RCALL  0768
....................           break;  
088A:  BRA    089A
....................  
....................        default:  
....................           lcd_send_byte(1,c);  
088C:  MOVLW  01
088E:  MOVLB  1
0890:  MOVWF  x9B
0892:  MOVFF  196,19C
0896:  MOVLB  0
0898:  RCALL  0768
....................           break;  
....................       }  
089A:  RETURN 0
.................... }  
....................  
.................... //------------------------------  
.................... #ifdef USE_LCD_RW  
....................     char lcd_getc(int8 x, int8 y)  
....................     {  
....................         char value;  
....................  
....................         lcd_gotoxy(x,y);  
....................  
....................         // Wait until busy flag is low.  
....................         while(bit_test(lcd_read_byte(),7));   
....................  
....................         output_high(LCD_RS);  
....................         value = lcd_read_byte();  
....................         output_low(lcd_RS);  
....................  
....................         return(value);  
....................     }  
.................... #endif 
....................      
.................... #define lcd_clear()    lcd_send_byte(0,1); ;delay_ms(25) 
....................  
.................... #include "tanimlamalar.h" 
.................... /*  
....................  * File:   tanimlamalar.h 
....................  * Author: ilyas 
....................  * 
....................  * Created on 22 Nisan 2020 Çarþamba, 12:49 
....................  */ 
....................  
.................... #ifndef TANIMLAMALAR_H 
.................... #define	TANIMLAMALAR_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................      
....................     #define MAX_DUTY    800 
....................  
....................     #define LED_PIN   PIN_A4 
....................  
....................     #define pcb_led_yak() output_low(LED_PIN); 
....................     #define pcb_led_son() output_high(LED_PIN); 
....................      
....................  
....................     #define SOL_BTN_PIN     PIN_A5 
....................     #define ORTA_BTN_PIN    PIN_A3 
....................     #define SAG_BTN_PIN     PIN_A2 
....................  
....................     #define GEC_LED_PIN     PIN_A6 
....................     #define DUR_LED_PIN     PIN_A7 
....................  
....................     #define SEVIYE_SENS1_PIN   PIN_E0 
....................     #define SEVIYE_SENS2_PIN   PIN_E1 
....................     #define SEVIYE_SENS3_PIN   PIN_E2 
....................  
....................     #define SEVIYE_LED1_PIN     PIN_B2 
....................     #define SEVIYE_LED2_PIN     PIN_B3 
.................... //    #define SEVIYE_LED3_PIN     PIN_B4 
.................... //    #define SEVIYE_LED4_PIN     PIN_B5 
....................     #define GEC2_LED_PIN     PIN_B4 
....................     #define DUR2_LED_PIN     PIN_B5 
....................  
....................     #define GIR_SENS1_PIN   PIN_B0 
....................     #define GIR_SENS2_PIN   PIN_B1 
....................      
....................     #define ROLE_PIN        PIN_C0 
....................     #define VALF_ROLE_PIN   PIN_C1   
....................  
....................     #define BUZZER_PIN  PIN_C5 
....................      
....................     #define MOTOR_PIN   PIN_C2 
....................  
....................     #define EE_ADR_SURE         0x00 
....................     #define EE_ADR_KUL_SAY_BL   0x01 
....................     #define EE_ADR_KUL_SAY_B2   0x02 
....................     #define EE_ADR_KUL_SAY_B3   0x03 
....................     #define EE_ADR_KUL_SAY_BH   0x04 
....................     #define EE_ADR_BEKLEME_SURE 0x05 
....................     #define EE_ADR_VALF_SURE    0x06 
....................     #define EE_ADR_DIL_SEC      0x10 
....................  
....................      
....................  
....................     #define GIR1_GIR2    1 
....................     #define GIR2_GIR1    2 
....................     #define GIRIS_YOK    0 
....................  
....................     #define DEPO_BOS    10 
....................     #define DEPO_MIN    11 
....................     #define DEPO_ORTA   12 
....................     #define DEPO_MAX    13 
....................  
....................     #define DIL_TR      20 
....................     #define DIL_FR      21 
....................     #define DIL_ALM     22 
....................     #define DIL_ING     23 
....................  
....................     #define KUL_SAY_EE_KAYDET 'K' 
....................     #define KUL_SAY_EE_OKU    'O' 
....................  
....................     #define bip_bekle() bipp(10,10,BUZZER_PIN) //sure,sayi,pin 
....................     #define bip_basla() bipp(50,2,BUZZER_PIN);  //sure,sayi,pin    
....................     #define bip_giris() bipp(100,5,BUZZER_PIN);  //sure,sayi,pin 
....................     #define bip_hata() bipp(250,5,BUZZER_PIN); 
....................  
....................     #define valfOn()  output_high(VALF_ROLE_PIN);   // basýncý boþaltýr Normalde kapalý valf  
....................     #define valfOff()  output_low(VALF_ROLE_PIN);   // basýncý tutar  Normalde kapalý valf  
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* TANIMLAMALAR_H */ 
....................  
....................  
....................  
.................... int menu_say = 0; 
.................... unsigned long long time_dezen_sure = 0; 
.................... unsigned long long time_valf_sure = 0; 
.................... unsigned long long time_bekle_sure = 0; 
.................... unsigned long long time_lcd = 0; 
....................  
.................... unsigned int32 kul_say = 0; 
.................... unsigned int8 dezen_sure = 0; 
.................... unsigned int8 valf_sure = 1; //15*100=1500mS 
.................... unsigned int8 bekle_sure = 0; 
.................... int8 giris_yon = 0; 
.................... int8 depo_durum = DEPO_BOS; 
....................  
.................... unsigned int16 an_sv1 = 0, an_sv2 = 0, an_sv3 = 0; 
....................  
.................... unsigned int8 dil_sec = 0; 
....................  
.................... char *lcd_msg_baslik; 
.................... char *lcd_msg_depo; 
.................... char *lcd_msg_depo_drm; 
.................... char *lcd_msg_sure; 
.................... char *lcd_msg_sayac; 
....................  
.................... void bipp(int sure, int sayi, long pin); 
.................... void sens_adc_oku(void); 
.................... char *splitStr(char *input_string, char *separator, int segment_number); 
.................... char *dilTxtGetir(char dil, char txt_sayi); 
.................... unsigned long kul_say_ee_islem(char islem, unsigned int32 sayi); 
....................  
.................... #include "lcd_islem.c" 
.................... #include "tanimlamalar.h" 
.................... /*  
....................  * File:   tanimlamalar.h 
....................  * Author: ilyas 
....................  * 
....................  * Created on 22 Nisan 2020 Çarþamba, 12:49 
....................  */ 
....................  
.................... #ifndef TANIMLAMALAR_H 
.................... #define	TANIMLAMALAR_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................      
....................     #define MAX_DUTY    800 
....................  
....................     #define LED_PIN   PIN_A4 
....................  
....................     #define pcb_led_yak() output_low(LED_PIN); 
....................     #define pcb_led_son() output_high(LED_PIN); 
....................      
....................  
....................     #define SOL_BTN_PIN     PIN_A5 
....................     #define ORTA_BTN_PIN    PIN_A3 
....................     #define SAG_BTN_PIN     PIN_A2 
....................  
....................     #define GEC_LED_PIN     PIN_A6 
....................     #define DUR_LED_PIN     PIN_A7 
....................  
....................     #define SEVIYE_SENS1_PIN   PIN_E0 
....................     #define SEVIYE_SENS2_PIN   PIN_E1 
....................     #define SEVIYE_SENS3_PIN   PIN_E2 
....................  
....................     #define SEVIYE_LED1_PIN     PIN_B2 
....................     #define SEVIYE_LED2_PIN     PIN_B3 
.................... //    #define SEVIYE_LED3_PIN     PIN_B4 
.................... //    #define SEVIYE_LED4_PIN     PIN_B5 
....................     #define GEC2_LED_PIN     PIN_B4 
....................     #define DUR2_LED_PIN     PIN_B5 
....................  
....................     #define GIR_SENS1_PIN   PIN_B0 
....................     #define GIR_SENS2_PIN   PIN_B1 
....................      
....................     #define ROLE_PIN        PIN_C0 
....................     #define VALF_ROLE_PIN   PIN_C1   
....................  
....................     #define BUZZER_PIN  PIN_C5 
....................      
....................     #define MOTOR_PIN   PIN_C2 
....................  
....................     #define EE_ADR_SURE         0x00 
....................     #define EE_ADR_KUL_SAY_BL   0x01 
....................     #define EE_ADR_KUL_SAY_B2   0x02 
....................     #define EE_ADR_KUL_SAY_B3   0x03 
....................     #define EE_ADR_KUL_SAY_BH   0x04 
....................     #define EE_ADR_BEKLEME_SURE 0x05 
....................     #define EE_ADR_VALF_SURE    0x06 
....................     #define EE_ADR_DIL_SEC      0x10 
....................  
....................      
....................  
....................     #define GIR1_GIR2    1 
....................     #define GIR2_GIR1    2 
....................     #define GIRIS_YOK    0 
....................  
....................     #define DEPO_BOS    10 
....................     #define DEPO_MIN    11 
....................     #define DEPO_ORTA   12 
....................     #define DEPO_MAX    13 
....................  
....................     #define DIL_TR      20 
....................     #define DIL_FR      21 
....................     #define DIL_ALM     22 
....................     #define DIL_ING     23 
....................  
....................     #define KUL_SAY_EE_KAYDET 'K' 
....................     #define KUL_SAY_EE_OKU    'O' 
....................  
....................     #define bip_bekle() bipp(10,10,BUZZER_PIN) //sure,sayi,pin 
....................     #define bip_basla() bipp(50,2,BUZZER_PIN);  //sure,sayi,pin    
....................     #define bip_giris() bipp(100,5,BUZZER_PIN);  //sure,sayi,pin 
....................     #define bip_hata() bipp(250,5,BUZZER_PIN); 
....................  
....................     #define valfOn()  output_high(VALF_ROLE_PIN);   // basýncý boþaltýr Normalde kapalý valf  
....................     #define valfOff()  output_low(VALF_ROLE_PIN);   // basýncý tutar  Normalde kapalý valf  
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* TANIMLAMALAR_H */ 
....................  
....................  
.................... #define MAX_MENU_DEGER  6 
.................... unsigned int16 duty = 0; 
....................  
....................  
.................... void motor_kontrol(int duty) { 
....................  
.................... } 
....................   
.................... void donanim_kontrol(void) { 
*
16A0:  MOVLB  1
16A2:  CLRF   x6C
....................     
....................     signed int btn = 0; 
....................     while(1){ 
....................          
....................         switch (btn) { 
16A4:  MOVF   x6C,W
16A6:  ADDLW  FA
16A8:  BTFSC  FD8.0
16AA:  BRA    1DE2
16AC:  ADDLW  06
16AE:  MOVLB  0
16B0:  GOTO   1DF2
....................             case 0: 
....................                 printf(lcd_putc, "\fROLE:"); 
16B4:  MOVLW  E8
16B6:  MOVWF  FF6
16B8:  MOVLW  03
16BA:  MOVWF  FF7
16BC:  CALL   089C
....................                 printf(lcd_putc, "\n<<<    <>    >>>"); 
16C0:  MOVLW  F0
16C2:  MOVWF  FF6
16C4:  MOVLW  03
16C6:  MOVWF  FF7
16C8:  CALL   089C
....................                 delay_ms(1000); 
16CC:  MOVLW  04
16CE:  MOVLB  1
16D0:  MOVWF  x6D
16D2:  MOVLW  FA
16D4:  MOVWF  x99
16D6:  MOVLB  0
16D8:  CALL   06CE
16DC:  MOVLB  1
16DE:  DECFSZ x6D,F
16E0:  BRA    16D2
....................                 bip_basla(); 
16E2:  MOVLW  32
16E4:  MOVWF  x93
16E6:  MOVLW  02
16E8:  MOVWF  x94
16EA:  MOVLW  7C
16EC:  MOVWF  x96
16EE:  MOVLW  15
16F0:  MOVWF  x95
16F2:  MOVLB  0
16F4:  CALL   08FE
....................                 do { 
....................                     if (!input(SAG_BTN_PIN)){ 
16F8:  BSF    F92.2
16FA:  BTFSC  F80.2
16FC:  BRA    170E
....................                         delay_ms(250); 
16FE:  MOVLW  FA
1700:  MOVLB  1
1702:  MOVWF  x99
1704:  MOVLB  0
1706:  CALL   06CE
....................                        output_high((ROLE_PIN)); 
170A:  BCF    F94.0
170C:  BSF    F8B.0
....................                     } 
....................                     if (!input(SOL_BTN_PIN)) { 
170E:  BSF    F92.5
1710:  BTFSC  F80.5
1712:  BRA    1724
....................                         delay_ms(250); 
1714:  MOVLW  FA
1716:  MOVLB  1
1718:  MOVWF  x99
171A:  MOVLB  0
171C:  CALL   06CE
....................                         output_low((ROLE_PIN)); 
1720:  BCF    F94.0
1722:  BCF    F8B.0
....................                     } 
....................  
....................                 }while (input(ORTA_BTN_PIN)); 
1724:  BSF    F92.3
1726:  BTFSC  F80.3
1728:  BRA    16F8
....................                 bip_basla(); 
172A:  MOVLW  32
172C:  MOVLB  1
172E:  MOVWF  x93
1730:  MOVLW  02
1732:  MOVWF  x94
1734:  MOVLW  7C
1736:  MOVWF  x96
1738:  MOVLW  15
173A:  MOVWF  x95
173C:  MOVLB  0
173E:  CALL   08FE
....................                 delay_ms(1000); 
1742:  MOVLW  04
1744:  MOVLB  1
1746:  MOVWF  x6D
1748:  MOVLW  FA
174A:  MOVWF  x99
174C:  MOVLB  0
174E:  CALL   06CE
1752:  MOVLB  1
1754:  DECFSZ x6D,F
1756:  BRA    1748
....................  
....................                 btn = 1; 
1758:  MOVLW  01
175A:  MOVWF  x6C
....................                 break; 
175C:  BRA    1DE2
....................             case 1: 
....................                 printf(lcd_putc, "\fSEVIYE:"); 
175E:  MOVLW  02
1760:  MOVWF  FF6
1762:  MOVLW  04
1764:  MOVWF  FF7
1766:  CALL   089C
....................                 printf(lcd_putc, "\n<<<    <>    >>>"); 
176A:  MOVLW  0C
176C:  MOVWF  FF6
176E:  MOVLW  04
1770:  MOVWF  FF7
1772:  CALL   089C
....................                 delay_ms(1000); 
1776:  MOVLW  04
1778:  MOVLB  1
177A:  MOVWF  x6D
177C:  MOVLW  FA
177E:  MOVWF  x99
1780:  MOVLB  0
1782:  CALL   06CE
1786:  MOVLB  1
1788:  DECFSZ x6D,F
178A:  BRA    177C
....................                 bip_basla(); 
178C:  MOVLW  32
178E:  MOVWF  x93
1790:  MOVLW  02
1792:  MOVWF  x94
1794:  MOVLW  7C
1796:  MOVWF  x96
1798:  MOVLW  15
179A:  MOVWF  x95
179C:  MOVLB  0
179E:  CALL   08FE
....................                 do { 
....................                      sens_adc_oku(); 
17A2:  RCALL  10BA
....................                       //if(input(SEVIYE_SENS1_PIN)) 
....................                     if(an_sv1>800)      //4 V gibi 
17A4:  MOVF   5B,W
17A6:  SUBLW  02
17A8:  BC    17BC
17AA:  XORLW  FF
17AC:  BNZ   17B4
17AE:  MOVF   5A,W
17B0:  SUBLW  20
17B2:  BC    17BC
....................                     { 
....................                         depo_durum=DEPO_BOS; 
17B4:  MOVLW  0A
17B6:  MOVWF  59
....................                         output_high(ROLE_PIN); // dalgýç pompaya gerilim ver. 
17B8:  BCF    F94.0
17BA:  BSF    F8B.0
....................                     } 
....................                     //if(!input(SEVIYE_SENS1_PIN)) 
....................                     if(an_sv1<700) //3.5 V 
17BC:  MOVF   5B,W
17BE:  SUBLW  02
17C0:  BNC   17D2
17C2:  BNZ   17CA
17C4:  MOVF   5A,W
17C6:  SUBLW  BB
17C8:  BNC   17D2
....................                     { 
....................                         depo_durum=DEPO_MIN; 
17CA:  MOVLW  0B
17CC:  MOVWF  59
....................                         output_high(ROLE_PIN); // dalgýç pompaya gerilim ver. 
17CE:  BCF    F94.0
17D0:  BSF    F8B.0
....................                     } 
....................                     //if(!input(SEVIYE_SENS1_PIN) && !input(SEVIYE_SENS2_PIN) ) 
....................                     if((an_sv1<700)&& (an_sv2<700)) 
17D2:  MOVF   5B,W
17D4:  SUBLW  02
17D6:  BNC   17F6
17D8:  BNZ   17E0
17DA:  MOVF   5A,W
17DC:  SUBLW  BB
17DE:  BNC   17F6
17E0:  MOVF   5D,W
17E2:  SUBLW  02
17E4:  BNC   17F6
17E6:  BNZ   17EE
17E8:  MOVF   5C,W
17EA:  SUBLW  BB
17EC:  BNC   17F6
....................                     { 
....................                         depo_durum=DEPO_ORTA; 
17EE:  MOVLW  0C
17F0:  MOVWF  59
....................                         output_high(ROLE_PIN); // dalgýç pompaya gerilim ver. 
17F2:  BCF    F94.0
17F4:  BSF    F8B.0
....................                     } 
....................                     //if(!input(SEVIYE_SENS1_PIN) && !input(SEVIYE_SENS2_PIN) && !input(SEVIYE_SENS3_PIN)) 
....................                     if((an_sv1<700)&& (an_sv2<700) && (an_sv3<700)) 
17F6:  MOVF   5B,W
17F8:  SUBLW  02
17FA:  BNC   1828
17FC:  BNZ   1804
17FE:  MOVF   5A,W
1800:  SUBLW  BB
1802:  BNC   1828
1804:  MOVF   5D,W
1806:  SUBLW  02
1808:  BNC   1828
180A:  BNZ   1812
180C:  MOVF   5C,W
180E:  SUBLW  BB
1810:  BNC   1828
1812:  MOVF   5F,W
1814:  SUBLW  02
1816:  BNC   1828
1818:  BNZ   1820
181A:  MOVF   5E,W
181C:  SUBLW  BB
181E:  BNC   1828
....................                     { 
....................                         depo_durum=DEPO_MAX; 
1820:  MOVLW  0D
1822:  MOVWF  59
....................                         output_low(ROLE_PIN);       //Dalgýç pompanýn gerilimini kes 
1824:  BCF    F94.0
1826:  BCF    F8B.0
....................                     } 
....................                       
....................                     lcd_msg_baslik=dilTxtGetir(dil_sec,1); 
1828:  MOVFF  60,193
182C:  MOVLW  01
182E:  MOVLB  1
1830:  MOVWF  x94
1832:  MOVLB  0
1834:  CALL   0BF4
1838:  MOVFF  02,62
183C:  MOVFF  01,61
....................                     printf(lcd_putc,"\f%s",lcd_msg_baslik); 
1840:  MOVLW  0C
1842:  MOVLB  1
1844:  MOVWF  x96
1846:  MOVLB  0
1848:  CALL   0842
184C:  MOVFF  62,FEA
1850:  MOVFF  61,FE9
1854:  CALL   0EA0
....................  
....................                     if(depo_durum==DEPO_BOS){ 
1858:  MOVF   59,W
185A:  SUBLW  0A
185C:  BNZ   18D6
....................                        lcd_msg_depo=dilTxtGetir(dil_sec,2); 
185E:  MOVFF  60,193
1862:  MOVLW  02
1864:  MOVLB  1
1866:  MOVWF  x94
1868:  MOVLB  0
186A:  CALL   0BF4
186E:  MOVFF  02,64
1872:  MOVFF  01,63
....................                        lcd_msg_depo_drm=dilTxtGetir(dil_sec,9); 
1876:  MOVFF  60,193
187A:  MOVLW  09
187C:  MOVLB  1
187E:  MOVWF  x94
1880:  MOVLB  0
1882:  CALL   0BF4
1886:  MOVFF  02,66
188A:  MOVFF  01,65
....................                        printf(lcd_putc,"\n%s:%s",lcd_msg_depo,lcd_msg_depo_drm);  
188E:  MOVLW  0A
1890:  MOVLB  1
1892:  MOVWF  x96
1894:  MOVLB  0
1896:  CALL   0842
189A:  MOVFF  64,FEA
189E:  MOVFF  63,FE9
18A2:  CALL   0EA0
18A6:  MOVLW  3A
18A8:  MOVLB  1
18AA:  MOVWF  x96
18AC:  MOVLB  0
18AE:  CALL   0842
18B2:  MOVFF  66,FEA
18B6:  MOVFF  65,FE9
18BA:  CALL   0EA0
....................                        delay_ms(1000); 
18BE:  MOVLW  04
18C0:  MOVLB  1
18C2:  MOVWF  x6D
18C4:  MOVLW  FA
18C6:  MOVWF  x99
18C8:  MOVLB  0
18CA:  CALL   06CE
18CE:  MOVLB  1
18D0:  DECFSZ x6D,F
18D2:  BRA    18C4
18D4:  MOVLB  0
....................                     } 
....................                     if(depo_durum==DEPO_MIN){ 
18D6:  MOVF   59,W
18D8:  SUBLW  0B
18DA:  BNZ   1920
....................                        lcd_msg_depo=dilTxtGetir(dil_sec,2);  
18DC:  MOVFF  60,193
18E0:  MOVLW  02
18E2:  MOVLB  1
18E4:  MOVWF  x94
18E6:  MOVLB  0
18E8:  CALL   0BF4
18EC:  MOVFF  02,64
18F0:  MOVFF  01,63
....................                        printf(lcd_putc,"\n%s:MIN-25",lcd_msg_depo);  
18F4:  MOVLW  0A
18F6:  MOVLB  1
18F8:  MOVWF  x96
18FA:  MOVLB  0
18FC:  CALL   0842
1900:  MOVFF  64,FEA
1904:  MOVFF  63,FE9
1908:  CALL   0EA0
190C:  MOVLW  21
190E:  MOVWF  FF6
1910:  MOVLW  04
1912:  MOVWF  FF7
1914:  MOVLW  07
1916:  MOVLB  1
1918:  MOVWF  x93
191A:  MOVLB  0
191C:  CALL   1016
....................                     } 
....................                     if(depo_durum==DEPO_ORTA){ 
1920:  MOVF   59,W
1922:  SUBLW  0C
1924:  BNZ   199A
....................                        lcd_msg_depo=dilTxtGetir(dil_sec,2);  
1926:  MOVFF  60,193
192A:  MOVLW  02
192C:  MOVLB  1
192E:  MOVWF  x94
1930:  MOVLB  0
1932:  CALL   0BF4
1936:  MOVFF  02,64
193A:  MOVFF  01,63
....................                        lcd_msg_depo_drm=dilTxtGetir(dil_sec,4); 
193E:  MOVFF  60,193
1942:  MOVLW  04
1944:  MOVLB  1
1946:  MOVWF  x94
1948:  MOVLB  0
194A:  CALL   0BF4
194E:  MOVFF  02,66
1952:  MOVFF  01,65
....................                        printf(lcd_putc,"\n%s:%s-50",lcd_msg_depo,lcd_msg_depo_drm);  
1956:  MOVLW  0A
1958:  MOVLB  1
195A:  MOVWF  x96
195C:  MOVLB  0
195E:  CALL   0842
1962:  MOVFF  64,FEA
1966:  MOVFF  63,FE9
196A:  CALL   0EA0
196E:  MOVLW  3A
1970:  MOVLB  1
1972:  MOVWF  x96
1974:  MOVLB  0
1976:  CALL   0842
197A:  MOVFF  66,FEA
197E:  MOVFF  65,FE9
1982:  CALL   0EA0
1986:  MOVLW  30
1988:  MOVWF  FF6
198A:  MOVLW  04
198C:  MOVWF  FF7
198E:  MOVLW  03
1990:  MOVLB  1
1992:  MOVWF  x93
1994:  MOVLB  0
1996:  CALL   1016
....................  
....................                     } 
....................                     if(depo_durum==DEPO_MAX){ 
199A:  MOVF   59,W
199C:  SUBLW  0D
199E:  BNZ   19E4
....................                        lcd_msg_depo=dilTxtGetir(dil_sec,2);  
19A0:  MOVFF  60,193
19A4:  MOVLW  02
19A6:  MOVLB  1
19A8:  MOVWF  x94
19AA:  MOVLB  0
19AC:  CALL   0BF4
19B0:  MOVFF  02,64
19B4:  MOVFF  01,63
....................                        printf(lcd_putc,"\n%s:MAX-100",lcd_msg_depo);  
19B8:  MOVLW  0A
19BA:  MOVLB  1
19BC:  MOVWF  x96
19BE:  MOVLB  0
19C0:  CALL   0842
19C4:  MOVFF  64,FEA
19C8:  MOVFF  63,FE9
19CC:  CALL   0EA0
19D0:  MOVLW  37
19D2:  MOVWF  FF6
19D4:  MOVLW  04
19D6:  MOVWF  FF7
19D8:  MOVLW  08
19DA:  MOVLB  1
19DC:  MOVWF  x93
19DE:  MOVLB  0
19E0:  CALL   1016
....................  
....................                     } 
....................                     delay_ms(250); 
19E4:  MOVLW  FA
19E6:  MOVLB  1
19E8:  MOVWF  x99
19EA:  MOVLB  0
19EC:  CALL   06CE
....................                      
....................               } while (input(ORTA_BTN_PIN)); 
19F0:  BSF    F92.3
19F2:  BTFSC  F80.3
19F4:  BRA    17A2
....................                 bip_basla(); 
19F6:  MOVLW  32
19F8:  MOVLB  1
19FA:  MOVWF  x93
19FC:  MOVLW  02
19FE:  MOVWF  x94
1A00:  MOVLW  7C
1A02:  MOVWF  x96
1A04:  MOVLW  15
1A06:  MOVWF  x95
1A08:  MOVLB  0
1A0A:  CALL   08FE
....................                 delay_ms(1000); 
1A0E:  MOVLW  04
1A10:  MOVLB  1
1A12:  MOVWF  x6D
1A14:  MOVLW  FA
1A16:  MOVWF  x99
1A18:  MOVLB  0
1A1A:  CALL   06CE
1A1E:  MOVLB  1
1A20:  DECFSZ x6D,F
1A22:  BRA    1A14
....................                 btn = 2; 
1A24:  MOVLW  02
1A26:  MOVWF  x6C
....................                 break; 
1A28:  BRA    1DE2
....................             case 2: 
....................                 printf(lcd_putc, "\fDUR LED:"); 
1A2A:  MOVLW  40
1A2C:  MOVWF  FF6
1A2E:  MOVLW  04
1A30:  MOVWF  FF7
1A32:  CALL   089C
....................                 printf(lcd_putc, "\n<<<    <>    >>>"); 
1A36:  MOVLW  4A
1A38:  MOVWF  FF6
1A3A:  MOVLW  04
1A3C:  MOVWF  FF7
1A3E:  CALL   089C
....................                 delay_ms(1000); 
1A42:  MOVLW  04
1A44:  MOVLB  1
1A46:  MOVWF  x6D
1A48:  MOVLW  FA
1A4A:  MOVWF  x99
1A4C:  MOVLB  0
1A4E:  CALL   06CE
1A52:  MOVLB  1
1A54:  DECFSZ x6D,F
1A56:  BRA    1A48
....................                 bip_basla(); 
1A58:  MOVLW  32
1A5A:  MOVWF  x93
1A5C:  MOVLW  02
1A5E:  MOVWF  x94
1A60:  MOVLW  7C
1A62:  MOVWF  x96
1A64:  MOVLW  15
1A66:  MOVWF  x95
1A68:  MOVLB  0
1A6A:  CALL   08FE
....................                 do { 
....................                     output_high((DUR_LED_PIN)); 
1A6E:  BCF    F92.7
1A70:  BSF    F89.7
....................                     delay_ms(100); 
1A72:  MOVLW  64
1A74:  MOVLB  1
1A76:  MOVWF  x99
1A78:  MOVLB  0
1A7A:  CALL   06CE
....................                     output_low((DUR_LED_PIN)); 
1A7E:  BCF    F92.7
1A80:  BCF    F89.7
....................                     delay_ms(100); 
1A82:  MOVLW  64
1A84:  MOVLB  1
1A86:  MOVWF  x99
1A88:  MOVLB  0
1A8A:  CALL   06CE
....................                 } while (input(ORTA_BTN_PIN)); 
1A8E:  BSF    F92.3
1A90:  BTFSC  F80.3
1A92:  BRA    1A6E
....................                 bip_basla(); 
1A94:  MOVLW  32
1A96:  MOVLB  1
1A98:  MOVWF  x93
1A9A:  MOVLW  02
1A9C:  MOVWF  x94
1A9E:  MOVLW  7C
1AA0:  MOVWF  x96
1AA2:  MOVLW  15
1AA4:  MOVWF  x95
1AA6:  MOVLB  0
1AA8:  CALL   08FE
....................                 delay_ms(1000); 
1AAC:  MOVLW  04
1AAE:  MOVLB  1
1AB0:  MOVWF  x6D
1AB2:  MOVLW  FA
1AB4:  MOVWF  x99
1AB6:  MOVLB  0
1AB8:  CALL   06CE
1ABC:  MOVLB  1
1ABE:  DECFSZ x6D,F
1AC0:  BRA    1AB2
....................                 btn = 3; 
1AC2:  MOVLW  03
1AC4:  MOVWF  x6C
....................                 break; 
1AC6:  BRA    1DE2
....................             case 3: 
....................                 printf(lcd_putc, "\fGEC LED:"); 
1AC8:  MOVLW  5C
1ACA:  MOVWF  FF6
1ACC:  MOVLW  04
1ACE:  MOVWF  FF7
1AD0:  CALL   089C
....................                 printf(lcd_putc, "\n<<<    <>    >>>"); 
1AD4:  MOVLW  66
1AD6:  MOVWF  FF6
1AD8:  MOVLW  04
1ADA:  MOVWF  FF7
1ADC:  CALL   089C
....................                 delay_ms(1000); 
1AE0:  MOVLW  04
1AE2:  MOVLB  1
1AE4:  MOVWF  x6D
1AE6:  MOVLW  FA
1AE8:  MOVWF  x99
1AEA:  MOVLB  0
1AEC:  CALL   06CE
1AF0:  MOVLB  1
1AF2:  DECFSZ x6D,F
1AF4:  BRA    1AE6
....................                 bip_basla(); 
1AF6:  MOVLW  32
1AF8:  MOVWF  x93
1AFA:  MOVLW  02
1AFC:  MOVWF  x94
1AFE:  MOVLW  7C
1B00:  MOVWF  x96
1B02:  MOVLW  15
1B04:  MOVWF  x95
1B06:  MOVLB  0
1B08:  CALL   08FE
....................                 do { 
....................                     output_high((GEC_LED_PIN)); 
1B0C:  BCF    F92.6
1B0E:  BSF    F89.6
....................                     delay_ms(100); 
1B10:  MOVLW  64
1B12:  MOVLB  1
1B14:  MOVWF  x99
1B16:  MOVLB  0
1B18:  CALL   06CE
....................                     output_low((GEC_LED_PIN)); 
1B1C:  BCF    F92.6
1B1E:  BCF    F89.6
....................                     delay_ms(100); 
1B20:  MOVLW  64
1B22:  MOVLB  1
1B24:  MOVWF  x99
1B26:  MOVLB  0
1B28:  CALL   06CE
....................                 } while (input(ORTA_BTN_PIN)); 
1B2C:  BSF    F92.3
1B2E:  BTFSC  F80.3
1B30:  BRA    1B0C
....................                 bip_basla(); 
1B32:  MOVLW  32
1B34:  MOVLB  1
1B36:  MOVWF  x93
1B38:  MOVLW  02
1B3A:  MOVWF  x94
1B3C:  MOVLW  7C
1B3E:  MOVWF  x96
1B40:  MOVLW  15
1B42:  MOVWF  x95
1B44:  MOVLB  0
1B46:  CALL   08FE
....................                 delay_ms(1000); 
1B4A:  MOVLW  04
1B4C:  MOVLB  1
1B4E:  MOVWF  x6D
1B50:  MOVLW  FA
1B52:  MOVWF  x99
1B54:  MOVLB  0
1B56:  CALL   06CE
1B5A:  MOVLB  1
1B5C:  DECFSZ x6D,F
1B5E:  BRA    1B50
....................                 btn = 4; 
1B60:  MOVLW  04
1B62:  MOVWF  x6C
....................                 break; 
1B64:  BRA    1DE2
....................             case 4: 
....................                 printf(lcd_putc, "\fGECIS SENS.:"); 
1B66:  MOVLW  78
1B68:  MOVWF  FF6
1B6A:  MOVLW  04
1B6C:  MOVWF  FF7
1B6E:  CALL   089C
....................                 printf(lcd_putc, "\n<<<    <>    >>>"); 
1B72:  MOVLW  86
1B74:  MOVWF  FF6
1B76:  MOVLW  04
1B78:  MOVWF  FF7
1B7A:  CALL   089C
....................                 delay_ms(1000); 
1B7E:  MOVLW  04
1B80:  MOVLB  1
1B82:  MOVWF  x6D
1B84:  MOVLW  FA
1B86:  MOVWF  x99
1B88:  MOVLB  0
1B8A:  CALL   06CE
1B8E:  MOVLB  1
1B90:  DECFSZ x6D,F
1B92:  BRA    1B84
....................                 bip_basla(); 
1B94:  MOVLW  32
1B96:  MOVWF  x93
1B98:  MOVLW  02
1B9A:  MOVWF  x94
1B9C:  MOVLW  7C
1B9E:  MOVWF  x96
1BA0:  MOVLW  15
1BA2:  MOVWF  x95
1BA4:  MOVLB  0
1BA6:  CALL   08FE
....................                 do { 
....................                     if (!input(GIR_SENS1_PIN)){ 
1BAA:  BSF    F93.0
1BAC:  BTFSC  F81.0
1BAE:  BRA    1BEC
....................                         printf(lcd_putc, "\fGECIS SENS.:"); 
1BB0:  MOVLW  98
1BB2:  MOVWF  FF6
1BB4:  MOVLW  04
1BB6:  MOVWF  FF7
1BB8:  CALL   089C
....................                         printf(lcd_putc, "\nGEC 1"); 
1BBC:  MOVLW  A6
1BBE:  MOVWF  FF6
1BC0:  MOVLW  04
1BC2:  MOVWF  FF7
1BC4:  CALL   089C
....................                         delay_ms(250); 
1BC8:  MOVLW  FA
1BCA:  MOVLB  1
1BCC:  MOVWF  x99
1BCE:  MOVLB  0
1BD0:  CALL   06CE
....................                         bip_hata(); 
1BD4:  MOVLW  FA
1BD6:  MOVLB  1
1BD8:  MOVWF  x93
1BDA:  MOVLW  05
1BDC:  MOVWF  x94
1BDE:  MOVLW  7C
1BE0:  MOVWF  x96
1BE2:  MOVLW  15
1BE4:  MOVWF  x95
1BE6:  MOVLB  0
1BE8:  CALL   08FE
....................                     } 
....................                     if (!input(GIR_SENS2_PIN)){ 
1BEC:  BSF    F93.1
1BEE:  BTFSC  F81.1
1BF0:  BRA    1C2E
....................                         printf(lcd_putc, "\fGECIS SENS.:"); 
1BF2:  MOVLW  AE
1BF4:  MOVWF  FF6
1BF6:  MOVLW  04
1BF8:  MOVWF  FF7
1BFA:  CALL   089C
....................                         printf(lcd_putc, "\nGEC 2"); 
1BFE:  MOVLW  BC
1C00:  MOVWF  FF6
1C02:  MOVLW  04
1C04:  MOVWF  FF7
1C06:  CALL   089C
....................                         delay_ms(250); 
1C0A:  MOVLW  FA
1C0C:  MOVLB  1
1C0E:  MOVWF  x99
1C10:  MOVLB  0
1C12:  CALL   06CE
....................                         bip_hata(); 
1C16:  MOVLW  FA
1C18:  MOVLB  1
1C1A:  MOVWF  x93
1C1C:  MOVLW  05
1C1E:  MOVWF  x94
1C20:  MOVLW  7C
1C22:  MOVWF  x96
1C24:  MOVLW  15
1C26:  MOVWF  x95
1C28:  MOVLB  0
1C2A:  CALL   08FE
....................                     } 
....................                 } while (input(ORTA_BTN_PIN)); 
1C2E:  BSF    F92.3
1C30:  BTFSC  F80.3
1C32:  BRA    1BAA
....................                 bip_basla(); 
1C34:  MOVLW  32
1C36:  MOVLB  1
1C38:  MOVWF  x93
1C3A:  MOVLW  02
1C3C:  MOVWF  x94
1C3E:  MOVLW  7C
1C40:  MOVWF  x96
1C42:  MOVLW  15
1C44:  MOVWF  x95
1C46:  MOVLB  0
1C48:  CALL   08FE
....................                 delay_ms(1000); 
1C4C:  MOVLW  04
1C4E:  MOVLB  1
1C50:  MOVWF  x6D
1C52:  MOVLW  FA
1C54:  MOVWF  x99
1C56:  MOVLB  0
1C58:  CALL   06CE
1C5C:  MOVLB  1
1C5E:  DECFSZ x6D,F
1C60:  BRA    1C52
....................                 btn = 5; 
1C62:  MOVLW  05
1C64:  MOVWF  x6C
....................                 break; 
1C66:  BRA    1DE2
....................             case 5: 
....................                 printf(lcd_putc, "\fMOTOR:"); 
1C68:  MOVLW  C4
1C6A:  MOVWF  FF6
1C6C:  MOVLW  04
1C6E:  MOVWF  FF7
1C70:  CALL   089C
....................                 printf(lcd_putc, "\n<<<    <>    >>>"); 
1C74:  MOVLW  CC
1C76:  MOVWF  FF6
1C78:  MOVLW  04
1C7A:  MOVWF  FF7
1C7C:  CALL   089C
....................                 delay_ms(1000); 
1C80:  MOVLW  04
1C82:  MOVLB  1
1C84:  MOVWF  x6D
1C86:  MOVLW  FA
1C88:  MOVWF  x99
1C8A:  MOVLB  0
1C8C:  CALL   06CE
1C90:  MOVLB  1
1C92:  DECFSZ x6D,F
1C94:  BRA    1C86
....................                 bip_basla(); 
1C96:  MOVLW  32
1C98:  MOVWF  x93
1C9A:  MOVLW  02
1C9C:  MOVWF  x94
1C9E:  MOVLW  7C
1CA0:  MOVWF  x96
1CA2:  MOVLW  15
1CA4:  MOVWF  x95
1CA6:  MOVLB  0
1CA8:  CALL   08FE
....................                 set_pwm1_duty(0); 
1CAC:  CLRF   FBE
....................                 duty=0; 
1CAE:  CLRF   x6C
1CB0:  CLRF   x6B
....................                 do { 
....................                    if (!input(SAG_BTN_PIN)) { 
1CB2:  BSF    F92.2
1CB4:  BTFSC  F80.2
1CB6:  BRA    1D1A
....................                         delay_ms(50); 
1CB8:  MOVLW  32
1CBA:  MOVLB  1
1CBC:  MOVWF  x99
1CBE:  MOVLB  0
1CC0:  CALL   06CE
....................                         duty += 1; 
1CC4:  MOVLW  01
1CC6:  ADDWF  x6B,F
1CC8:  MOVLW  00
1CCA:  ADDWFC x6C,F
....................                         if (duty > 1000) duty = 1000; 
1CCC:  MOVF   x6C,W
1CCE:  SUBLW  02
1CD0:  BC    1CE4
1CD2:  XORLW  FF
1CD4:  BNZ   1CDC
1CD6:  MOVF   x6B,W
1CD8:  SUBLW  E8
1CDA:  BC    1CE4
1CDC:  MOVLW  03
1CDE:  MOVWF  x6C
1CE0:  MOVLW  E8
1CE2:  MOVWF  x6B
....................                          printf(lcd_putc, "\f\nduty:%Lu   ", duty); 
1CE4:  MOVLW  DE
1CE6:  MOVWF  FF6
1CE8:  MOVLW  04
1CEA:  MOVWF  FF7
1CEC:  MOVLW  07
1CEE:  MOVLB  1
1CF0:  MOVWF  x93
1CF2:  MOVLB  0
1CF4:  CALL   1016
1CF8:  MOVLW  10
1CFA:  MOVWF  FE9
1CFC:  MOVFF  6C,172
1D00:  MOVFF  6B,171
1D04:  RCALL  15DA
1D06:  MOVLW  E8
1D08:  MOVWF  FF6
1D0A:  MOVLW  04
1D0C:  MOVWF  FF7
1D0E:  MOVLW  03
1D10:  MOVLB  1
1D12:  MOVWF  x93
1D14:  MOVLB  0
1D16:  CALL   1016
....................                     } 
....................  
....................                     if (!input(SOL_BTN_PIN)) { 
1D1A:  BSF    F92.5
1D1C:  BTFSC  F80.5
1D1E:  BRA    1D7A
....................                         delay_ms(50); 
1D20:  MOVLW  32
1D22:  MOVLB  1
1D24:  MOVWF  x99
1D26:  MOVLB  0
1D28:  CALL   06CE
....................                         duty -= 1; 
1D2C:  MOVLW  01
1D2E:  SUBWF  x6B,F
1D30:  MOVLW  00
1D32:  SUBWFB x6C,F
....................                         if (duty < 10) duty = 10; 
1D34:  MOVF   x6C,F
1D36:  BNZ   1D44
1D38:  MOVF   x6B,W
1D3A:  SUBLW  09
1D3C:  BNC   1D44
1D3E:  CLRF   x6C
1D40:  MOVLW  0A
1D42:  MOVWF  x6B
....................                         printf(lcd_putc, "\f\nduty:%Lu   ", duty); 
1D44:  MOVLW  EC
1D46:  MOVWF  FF6
1D48:  MOVLW  04
1D4A:  MOVWF  FF7
1D4C:  MOVLW  07
1D4E:  MOVLB  1
1D50:  MOVWF  x93
1D52:  MOVLB  0
1D54:  CALL   1016
1D58:  MOVLW  10
1D5A:  MOVWF  FE9
1D5C:  MOVFF  6C,172
1D60:  MOVFF  6B,171
1D64:  RCALL  15DA
1D66:  MOVLW  F6
1D68:  MOVWF  FF6
1D6A:  MOVLW  04
1D6C:  MOVWF  FF7
1D6E:  MOVLW  03
1D70:  MOVLB  1
1D72:  MOVWF  x93
1D74:  MOVLB  0
1D76:  CALL   1016
....................                     } 
....................  
....................                     set_pwm1_duty(duty); 
1D7A:  MOVFF  6C,02
1D7E:  MOVFF  6B,01
1D82:  RRCF   02,F
1D84:  RRCF   01,F
1D86:  RRCF   02,F
1D88:  RRCF   01,F
1D8A:  RRCF   02,F
1D8C:  MOVFF  01,FBE
1D90:  RRCF   02,F
1D92:  RRCF   02,W
1D94:  ANDLW  30
1D96:  MOVWF  00
1D98:  MOVF   FBD,W
1D9A:  ANDLW  CF
1D9C:  IORWF  00,W
1D9E:  MOVWF  FBD
....................  
....................                 } while (input(ORTA_BTN_PIN)); 
1DA0:  BSF    F92.3
1DA2:  BTFSC  F80.3
1DA4:  BRA    1CB2
....................                 duty=0; 
1DA6:  CLRF   x6C
1DA8:  CLRF   x6B
....................                 bip_basla(); 
1DAA:  MOVLW  32
1DAC:  MOVLB  1
1DAE:  MOVWF  x93
1DB0:  MOVLW  02
1DB2:  MOVWF  x94
1DB4:  MOVLW  7C
1DB6:  MOVWF  x96
1DB8:  MOVLW  15
1DBA:  MOVWF  x95
1DBC:  MOVLB  0
1DBE:  CALL   08FE
....................                 delay_ms(1000); 
1DC2:  MOVLW  04
1DC4:  MOVLB  1
1DC6:  MOVWF  x6D
1DC8:  MOVLW  FA
1DCA:  MOVWF  x99
1DCC:  MOVLB  0
1DCE:  CALL   06CE
1DD2:  MOVLB  1
1DD4:  DECFSZ x6D,F
1DD6:  BRA    1DC8
....................                 set_pwm1_duty(0); 
1DD8:  CLRF   FBE
....................                 btn = 6; 
1DDA:  MOVLW  06
1DDC:  MOVWF  x6C
....................                  
....................                 break; 
1DDE:  BRA    1DE2
1DE0:  MOVLB  1
....................         } 
....................          
....................         if(btn==6)break; 
1DE2:  MOVF   x6C,W
1DE4:  SUBLW  06
1DE6:  BTFSC  FD8.2
1DE8:  BRA    1DEC
1DEA:  BRA    16A4
....................     } 
1DEC:  MOVLB  0
1DEE:  GOTO   26FE (RETURN)
....................      
....................  
.................... } 
.................... void sureAyar(void){ 
*
11D6:  MOVFF  FF2,16F
11DA:  BCF    FF2.7
11DC:  CLRF   FA9
11DE:  BCF    FA6.6
11E0:  BCF    FA6.7
11E2:  BSF    FA6.0
11E4:  MOVF   FA8,W
11E6:  MOVLB  1
11E8:  BTFSC  x6F.7
11EA:  BSF    FF2.7
11EC:  MOVWF  x6E
....................     char *sure_str; 
....................     int sn=read_eeprom(EE_ADR_SURE); 
....................     if(sn>100) sn=1; 
11EE:  MOVF   x6E,W
11F0:  SUBLW  64
11F2:  BC    11F8
11F4:  MOVLW  01
11F6:  MOVWF  x6E
....................     sure_str=dilTxtGetir(dil_sec,3); 
11F8:  MOVFF  60,193
11FC:  MOVLW  03
11FE:  MOVWF  x94
1200:  MOVLB  0
1202:  RCALL  0BF4
1204:  MOVFF  02,16D
1208:  MOVFF  01,16C
....................     printf(lcd_putc,"\f%s=%u S\n",sure_str,sn); 
120C:  MOVLW  0C
120E:  MOVLB  1
1210:  MOVWF  x96
1212:  MOVLB  0
1214:  CALL   0842
1218:  MOVFF  16D,FEA
121C:  MOVFF  16C,FE9
1220:  RCALL  0EA0
1222:  MOVLW  3D
1224:  MOVLB  1
1226:  MOVWF  x96
1228:  MOVLB  0
122A:  CALL   0842
122E:  MOVFF  16E,16F
1232:  MOVLW  1B
1234:  MOVLB  1
1236:  MOVWF  x70
1238:  MOVLB  0
123A:  RCALL  1154
123C:  MOVLW  00
123E:  MOVWF  FF6
1240:  MOVLW  05
1242:  MOVWF  FF7
1244:  MOVLW  03
1246:  MOVLB  1
1248:  MOVWF  x93
124A:  MOVLB  0
124C:  RCALL  1016
....................     printf(lcd_putc,"\n<<<    <>    >>>"); 
124E:  MOVLW  04
1250:  MOVWF  FF6
1252:  MOVLW  05
1254:  MOVWF  FF7
1256:  CALL   089C
....................     delay_ms(1000); 
125A:  MOVLW  04
125C:  MOVLB  1
125E:  MOVWF  x6F
1260:  MOVLW  FA
1262:  MOVWF  x99
1264:  MOVLB  0
1266:  CALL   06CE
126A:  MOVLB  1
126C:  DECFSZ x6F,F
126E:  BRA    1260
....................      
....................     do{ 
....................         lcd_gotoxy(1,1); 
1270:  MOVLW  01
1272:  MOVWF  x97
1274:  MOVWF  x98
1276:  MOVLB  0
1278:  CALL   081C
....................         printf(lcd_putc,"\f%s=%u S\n",sure_str,sn); 
127C:  MOVLW  0C
127E:  MOVLB  1
1280:  MOVWF  x96
1282:  MOVLB  0
1284:  CALL   0842
1288:  MOVFF  16D,FEA
128C:  MOVFF  16C,FE9
1290:  RCALL  0EA0
1292:  MOVLW  3D
1294:  MOVLB  1
1296:  MOVWF  x96
1298:  MOVLB  0
129A:  CALL   0842
129E:  MOVFF  16E,16F
12A2:  MOVLW  1B
12A4:  MOVLB  1
12A6:  MOVWF  x70
12A8:  MOVLB  0
12AA:  RCALL  1154
12AC:  MOVLW  1C
12AE:  MOVWF  FF6
12B0:  MOVLW  05
12B2:  MOVWF  FF7
12B4:  MOVLW  03
12B6:  MOVLB  1
12B8:  MOVWF  x93
12BA:  MOVLB  0
12BC:  RCALL  1016
....................         printf(lcd_putc,"\n<<<    <>    >>>"); 
12BE:  MOVLW  20
12C0:  MOVWF  FF6
12C2:  MOVLW  05
12C4:  MOVWF  FF7
12C6:  CALL   089C
....................         if(!input(SOL_BTN_PIN)){ 
12CA:  BSF    F92.5
12CC:  BTFSC  F80.5
12CE:  BRA    1302
....................             delay_ms(100); 
12D0:  MOVLW  64
12D2:  MOVLB  1
12D4:  MOVWF  x99
12D6:  MOVLB  0
12D8:  CALL   06CE
....................             bip_basla(); 
12DC:  MOVLW  32
12DE:  MOVLB  1
12E0:  MOVWF  x93
12E2:  MOVLW  02
12E4:  MOVWF  x94
12E6:  MOVLW  7C
12E8:  MOVWF  x96
12EA:  MOVLW  15
12EC:  MOVWF  x95
12EE:  MOVLB  0
12F0:  CALL   08FE
....................             sn--; 
12F4:  MOVLB  1
12F6:  DECF   x6E,F
....................             if(sn<1) sn=1; 
12F8:  MOVF   x6E,F
12FA:  BNZ   1300
12FC:  MOVLW  01
12FE:  MOVWF  x6E
1300:  MOVLB  0
....................         } 
....................         if(!input(SAG_BTN_PIN)){ 
1302:  BSF    F92.2
1304:  BTFSC  F80.2
1306:  BRA    1332
....................             delay_ms(100); 
1308:  MOVLW  64
130A:  MOVLB  1
130C:  MOVWF  x99
130E:  MOVLB  0
1310:  CALL   06CE
....................             bip_basla(); 
1314:  MOVLW  32
1316:  MOVLB  1
1318:  MOVWF  x93
131A:  MOVLW  02
131C:  MOVWF  x94
131E:  MOVLW  7C
1320:  MOVWF  x96
1322:  MOVLW  15
1324:  MOVWF  x95
1326:  MOVLB  0
1328:  CALL   08FE
....................             sn++; 
132C:  MOVLB  1
132E:  INCF   x6E,F
1330:  MOVLB  0
....................             if(sn>300) sn=60; 
....................         } 
....................         delay_ms(100); 
1332:  MOVLW  64
1334:  MOVLB  1
1336:  MOVWF  x99
1338:  MOVLB  0
133A:  CALL   06CE
....................     } while(input(ORTA_BTN_PIN)); 
133E:  BSF    F92.3
1340:  BTFSS  F80.3
1342:  BRA    1348
1344:  MOVLB  1
1346:  BRA    1270
....................      bip_basla(); 
1348:  MOVLW  32
134A:  MOVLB  1
134C:  MOVWF  x93
134E:  MOVLW  02
1350:  MOVWF  x94
1352:  MOVLW  7C
1354:  MOVWF  x96
1356:  MOVLW  15
1358:  MOVWF  x95
135A:  MOVLB  0
135C:  CALL   08FE
....................       
....................      write_eeprom(EE_ADR_SURE,sn); 
1360:  MOVF   FF2,W
1362:  MOVWF  00
1364:  BCF    FF2.7
1366:  CLRF   FA9
1368:  MOVFF  16E,FA8
136C:  BCF    FA6.6
136E:  BCF    FA6.7
1370:  BSF    FA6.2
1372:  MOVLB  F
1374:  MOVLW  55
1376:  MOVWF  FA7
1378:  MOVLW  AA
137A:  MOVWF  FA7
137C:  BSF    FA6.1
137E:  BTFSC  FA6.1
1380:  BRA    137E
1382:  BCF    FA6.2
1384:  MOVF   00,W
1386:  IORWF  FF2,F
....................      dezen_sure=sn; 
1388:  MOVFF  16E,55
....................      sure_str=dilTxtGetir(dil_sec,5); 
138C:  MOVFF  60,193
1390:  MOVLW  05
1392:  MOVLB  1
1394:  MOVWF  x94
1396:  MOVLB  0
1398:  RCALL  0BF4
139A:  MOVFF  02,16D
139E:  MOVFF  01,16C
....................      printf(lcd_putc,"\f%s",sure_str); 
13A2:  MOVLW  0C
13A4:  MOVLB  1
13A6:  MOVWF  x96
13A8:  MOVLB  0
13AA:  CALL   0842
13AE:  MOVFF  16D,FEA
13B2:  MOVFF  16C,FE9
13B6:  RCALL  0EA0
....................       
....................      delay_ms(1000); 
13B8:  MOVLW  04
13BA:  MOVLB  1
13BC:  MOVWF  x6F
13BE:  MOVLW  FA
13C0:  MOVWF  x99
13C2:  MOVLB  0
13C4:  CALL   06CE
13C8:  MOVLB  1
13CA:  DECFSZ x6F,F
13CC:  BRA    13BE
13CE:  MOVLB  0
13D0:  GOTO   25F6 (RETURN)
.................... } 
....................  
.................... void beklemeSureAyar(void){ 
13D4:  MOVFF  FF2,16F
13D8:  BCF    FF2.7
13DA:  MOVLW  05
13DC:  MOVWF  FA9
13DE:  BCF    FA6.6
13E0:  BCF    FA6.7
13E2:  BSF    FA6.0
13E4:  MOVF   FA8,W
13E6:  MOVLB  1
13E8:  BTFSC  x6F.7
13EA:  BSF    FF2.7
13EC:  MOVWF  x6E
....................     char *sure_str; 
....................     int sn=read_eeprom(EE_ADR_BEKLEME_SURE); 
....................     if(sn>100) sn=1; 
13EE:  MOVF   x6E,W
13F0:  SUBLW  64
13F2:  BC    13F8
13F4:  MOVLW  01
13F6:  MOVWF  x6E
....................     sure_str=dilTxtGetir(dil_sec,3); 
13F8:  MOVFF  60,193
13FC:  MOVLW  03
13FE:  MOVWF  x94
1400:  MOVLB  0
1402:  CALL   0BF4
1406:  MOVFF  02,16D
140A:  MOVFF  01,16C
....................     printf(lcd_putc,"\f%s=%u S\n",sure_str,sn); 
140E:  MOVLW  0C
1410:  MOVLB  1
1412:  MOVWF  x96
1414:  MOVLB  0
1416:  CALL   0842
141A:  MOVFF  16D,FEA
141E:  MOVFF  16C,FE9
1422:  RCALL  0EA0
1424:  MOVLW  3D
1426:  MOVLB  1
1428:  MOVWF  x96
142A:  MOVLB  0
142C:  CALL   0842
1430:  MOVFF  16E,16F
1434:  MOVLW  1B
1436:  MOVLB  1
1438:  MOVWF  x70
143A:  MOVLB  0
143C:  RCALL  1154
143E:  MOVLW  38
1440:  MOVWF  FF6
1442:  MOVLW  05
1444:  MOVWF  FF7
1446:  MOVLW  03
1448:  MOVLB  1
144A:  MOVWF  x93
144C:  MOVLB  0
144E:  RCALL  1016
....................     printf(lcd_putc,"\n<<<    <>    >>>"); 
1450:  MOVLW  3C
1452:  MOVWF  FF6
1454:  MOVLW  05
1456:  MOVWF  FF7
1458:  CALL   089C
....................     delay_ms(1000); 
145C:  MOVLW  04
145E:  MOVLB  1
1460:  MOVWF  x6F
1462:  MOVLW  FA
1464:  MOVWF  x99
1466:  MOVLB  0
1468:  CALL   06CE
146C:  MOVLB  1
146E:  DECFSZ x6F,F
1470:  BRA    1462
....................      
....................     do{ 
....................         lcd_gotoxy(1,1); 
1472:  MOVLW  01
1474:  MOVWF  x97
1476:  MOVWF  x98
1478:  MOVLB  0
147A:  CALL   081C
....................         printf(lcd_putc,"\f%s=%u S\n",sure_str,sn); 
147E:  MOVLW  0C
1480:  MOVLB  1
1482:  MOVWF  x96
1484:  MOVLB  0
1486:  CALL   0842
148A:  MOVFF  16D,FEA
148E:  MOVFF  16C,FE9
1492:  RCALL  0EA0
1494:  MOVLW  3D
1496:  MOVLB  1
1498:  MOVWF  x96
149A:  MOVLB  0
149C:  CALL   0842
14A0:  MOVFF  16E,16F
14A4:  MOVLW  1B
14A6:  MOVLB  1
14A8:  MOVWF  x70
14AA:  MOVLB  0
14AC:  RCALL  1154
14AE:  MOVLW  54
14B0:  MOVWF  FF6
14B2:  MOVLW  05
14B4:  MOVWF  FF7
14B6:  MOVLW  03
14B8:  MOVLB  1
14BA:  MOVWF  x93
14BC:  MOVLB  0
14BE:  RCALL  1016
....................         printf(lcd_putc,"\n<<<    <>    >>>"); 
14C0:  MOVLW  58
14C2:  MOVWF  FF6
14C4:  MOVLW  05
14C6:  MOVWF  FF7
14C8:  CALL   089C
....................         if(!input(SOL_BTN_PIN)){ 
14CC:  BSF    F92.5
14CE:  BTFSC  F80.5
14D0:  BRA    1504
....................             delay_ms(100); 
14D2:  MOVLW  64
14D4:  MOVLB  1
14D6:  MOVWF  x99
14D8:  MOVLB  0
14DA:  CALL   06CE
....................             bip_basla(); 
14DE:  MOVLW  32
14E0:  MOVLB  1
14E2:  MOVWF  x93
14E4:  MOVLW  02
14E6:  MOVWF  x94
14E8:  MOVLW  7C
14EA:  MOVWF  x96
14EC:  MOVLW  15
14EE:  MOVWF  x95
14F0:  MOVLB  0
14F2:  CALL   08FE
....................             sn--; 
14F6:  MOVLB  1
14F8:  DECF   x6E,F
....................             if(sn<1) sn=1; 
14FA:  MOVF   x6E,F
14FC:  BNZ   1502
14FE:  MOVLW  01
1500:  MOVWF  x6E
1502:  MOVLB  0
....................         } 
....................         if(!input(SAG_BTN_PIN)){ 
1504:  BSF    F92.2
1506:  BTFSC  F80.2
1508:  BRA    1534
....................             delay_ms(100); 
150A:  MOVLW  64
150C:  MOVLB  1
150E:  MOVWF  x99
1510:  MOVLB  0
1512:  CALL   06CE
....................             bip_basla(); 
1516:  MOVLW  32
1518:  MOVLB  1
151A:  MOVWF  x93
151C:  MOVLW  02
151E:  MOVWF  x94
1520:  MOVLW  7C
1522:  MOVWF  x96
1524:  MOVLW  15
1526:  MOVWF  x95
1528:  MOVLB  0
152A:  CALL   08FE
....................             sn++; 
152E:  MOVLB  1
1530:  INCF   x6E,F
1532:  MOVLB  0
....................             if(sn>300) sn=60; 
....................         } 
....................         delay_ms(100); 
1534:  MOVLW  64
1536:  MOVLB  1
1538:  MOVWF  x99
153A:  MOVLB  0
153C:  CALL   06CE
....................     } while(input(ORTA_BTN_PIN)); 
1540:  BSF    F92.3
1542:  BTFSS  F80.3
1544:  BRA    154A
1546:  MOVLB  1
1548:  BRA    1472
....................      bip_basla(); 
154A:  MOVLW  32
154C:  MOVLB  1
154E:  MOVWF  x93
1550:  MOVLW  02
1552:  MOVWF  x94
1554:  MOVLW  7C
1556:  MOVWF  x96
1558:  MOVLW  15
155A:  MOVWF  x95
155C:  MOVLB  0
155E:  CALL   08FE
....................       
....................      write_eeprom( EE_ADR_BEKLEME_SURE,sn); 
1562:  MOVF   FF2,W
1564:  MOVWF  00
1566:  BCF    FF2.7
1568:  MOVLW  05
156A:  MOVWF  FA9
156C:  MOVFF  16E,FA8
1570:  BCF    FA6.6
1572:  BCF    FA6.7
1574:  BSF    FA6.2
1576:  MOVLB  F
1578:  MOVLW  55
157A:  MOVWF  FA7
157C:  MOVLW  AA
157E:  MOVWF  FA7
1580:  BSF    FA6.1
1582:  BTFSC  FA6.1
1584:  BRA    1582
1586:  BCF    FA6.2
1588:  MOVF   00,W
158A:  IORWF  FF2,F
....................      bekle_sure=sn; 
158C:  MOVFF  16E,57
....................      sure_str=dilTxtGetir(dil_sec,5); 
1590:  MOVFF  60,193
1594:  MOVLW  05
1596:  MOVLB  1
1598:  MOVWF  x94
159A:  MOVLB  0
159C:  CALL   0BF4
15A0:  MOVFF  02,16D
15A4:  MOVFF  01,16C
....................      printf(lcd_putc,"\f%s",sure_str); 
15A8:  MOVLW  0C
15AA:  MOVLB  1
15AC:  MOVWF  x96
15AE:  MOVLB  0
15B0:  CALL   0842
15B4:  MOVFF  16D,FEA
15B8:  MOVFF  16C,FE9
15BC:  RCALL  0EA0
....................       
....................      delay_ms(1000); 
15BE:  MOVLW  04
15C0:  MOVLB  1
15C2:  MOVWF  x6F
15C4:  MOVLW  FA
15C6:  MOVWF  x99
15C8:  MOVLB  0
15CA:  CALL   06CE
15CE:  MOVLB  1
15D0:  DECFSZ x6F,F
15D2:  BRA    15C4
15D4:  MOVLB  0
15D6:  GOTO   267A (RETURN)
.................... } 
....................  
.................... void valfSureAyar(void){ 
*
2294:  MOVFF  FF2,16F
2298:  BCF    FF2.7
229A:  MOVLW  06
229C:  MOVWF  FA9
229E:  BCF    FA6.6
22A0:  BCF    FA6.7
22A2:  BSF    FA6.0
22A4:  MOVF   FA8,W
22A6:  MOVLB  1
22A8:  BTFSC  x6F.7
22AA:  BSF    FF2.7
22AC:  MOVWF  x6E
....................     char *sure_str; 
....................     int sure=read_eeprom(EE_ADR_VALF_SURE); 
....................     if(sure>250) sure=1;     //10*100=1 saniye 
22AE:  MOVF   x6E,W
22B0:  SUBLW  FA
22B2:  BC    22B8
22B4:  MOVLW  01
22B6:  MOVWF  x6E
....................     sure_str=dilTxtGetir(dil_sec,3); 
22B8:  MOVFF  60,193
22BC:  MOVLW  03
22BE:  MOVWF  x94
22C0:  MOVLB  0
22C2:  CALL   0BF4
22C6:  MOVFF  02,16D
22CA:  MOVFF  01,16C
....................     printf(lcd_putc,"\f%s=%u S\n",sure_str,sure); 
22CE:  MOVLW  0C
22D0:  MOVLB  1
22D2:  MOVWF  x96
22D4:  MOVLB  0
22D6:  CALL   0842
22DA:  MOVFF  16D,FEA
22DE:  MOVFF  16C,FE9
22E2:  CALL   0EA0
22E6:  MOVLW  3D
22E8:  MOVLB  1
22EA:  MOVWF  x96
22EC:  MOVLB  0
22EE:  CALL   0842
22F2:  MOVFF  16E,16F
22F6:  MOVLW  1B
22F8:  MOVLB  1
22FA:  MOVWF  x70
22FC:  MOVLB  0
22FE:  CALL   1154
2302:  MOVLW  70
2304:  MOVWF  FF6
2306:  MOVLW  05
2308:  MOVWF  FF7
230A:  MOVLW  03
230C:  MOVLB  1
230E:  MOVWF  x93
2310:  MOVLB  0
2312:  CALL   1016
....................     printf(lcd_putc,"\n<<<    <>    >>>"); 
2316:  MOVLW  74
2318:  MOVWF  FF6
231A:  MOVLW  05
231C:  MOVWF  FF7
231E:  CALL   089C
....................     delay_ms(1000); 
2322:  MOVLW  04
2324:  MOVLB  1
2326:  MOVWF  x6F
2328:  MOVLW  FA
232A:  MOVWF  x99
232C:  MOVLB  0
232E:  CALL   06CE
2332:  MOVLB  1
2334:  DECFSZ x6F,F
2336:  BRA    2328
....................      
....................     do{ 
....................         lcd_gotoxy(1,1); 
2338:  MOVLW  01
233A:  MOVWF  x97
233C:  MOVWF  x98
233E:  MOVLB  0
2340:  CALL   081C
....................         printf(lcd_putc,"\f%s=%Lu mS\n",sure_str,(unsigned long)(sure*100L)); 
2344:  MOVLB  1
2346:  CLRF   x70
2348:  MOVFF  16E,16F
234C:  CLRF   x72
234E:  MOVLW  64
2350:  MOVWF  x71
2352:  MOVLB  0
2354:  CALL   1098
2358:  MOVFF  02,170
235C:  MOVFF  01,16F
2360:  MOVLW  0C
2362:  MOVLB  1
2364:  MOVWF  x96
2366:  MOVLB  0
2368:  CALL   0842
236C:  MOVFF  16D,FEA
2370:  MOVFF  16C,FE9
2374:  CALL   0EA0
2378:  MOVLW  3D
237A:  MOVLB  1
237C:  MOVWF  x96
237E:  MOVLB  0
2380:  CALL   0842
2384:  MOVLW  10
2386:  MOVWF  FE9
2388:  MOVFF  170,172
238C:  MOVFF  16F,171
2390:  CALL   15DA
2394:  MOVLW  8D
2396:  MOVWF  FF6
2398:  MOVLW  05
239A:  MOVWF  FF7
239C:  MOVLW  04
239E:  MOVLB  1
23A0:  MOVWF  x93
23A2:  MOVLB  0
23A4:  CALL   1016
....................         printf(lcd_putc,"\n<<<    <>    >>>"); 
23A8:  MOVLW  92
23AA:  MOVWF  FF6
23AC:  MOVLW  05
23AE:  MOVWF  FF7
23B0:  CALL   089C
....................         if(!input(SOL_BTN_PIN)){ 
23B4:  BSF    F92.5
23B6:  BTFSC  F80.5
23B8:  BRA    23EC
....................             delay_ms(100); 
23BA:  MOVLW  64
23BC:  MOVLB  1
23BE:  MOVWF  x99
23C0:  MOVLB  0
23C2:  CALL   06CE
....................             bip_basla(); 
23C6:  MOVLW  32
23C8:  MOVLB  1
23CA:  MOVWF  x93
23CC:  MOVLW  02
23CE:  MOVWF  x94
23D0:  MOVLW  7C
23D2:  MOVWF  x96
23D4:  MOVLW  15
23D6:  MOVWF  x95
23D8:  MOVLB  0
23DA:  CALL   08FE
....................             sure--; 
23DE:  MOVLB  1
23E0:  DECF   x6E,F
....................             if(sure<1) sure=1; 
23E2:  MOVF   x6E,F
23E4:  BNZ   23EA
23E6:  MOVLW  01
23E8:  MOVWF  x6E
23EA:  MOVLB  0
....................         } 
....................         if(!input(SAG_BTN_PIN)){ 
23EC:  BSF    F92.2
23EE:  BTFSC  F80.2
23F0:  BRA    2426
....................             delay_ms(100); 
23F2:  MOVLW  64
23F4:  MOVLB  1
23F6:  MOVWF  x99
23F8:  MOVLB  0
23FA:  CALL   06CE
....................             bip_basla(); 
23FE:  MOVLW  32
2400:  MOVLB  1
2402:  MOVWF  x93
2404:  MOVLW  02
2406:  MOVWF  x94
2408:  MOVLW  7C
240A:  MOVWF  x96
240C:  MOVLW  15
240E:  MOVWF  x95
2410:  MOVLB  0
2412:  CALL   08FE
....................             sure++; 
2416:  MOVLB  1
2418:  INCF   x6E,F
....................             if(sure>100) sure=100; 
241A:  MOVF   x6E,W
241C:  SUBLW  64
241E:  BC    2424
2420:  MOVLW  64
2422:  MOVWF  x6E
2424:  MOVLB  0
....................         } 
....................         delay_ms(100); 
2426:  MOVLW  64
2428:  MOVLB  1
242A:  MOVWF  x99
242C:  MOVLB  0
242E:  CALL   06CE
....................     } while(input(ORTA_BTN_PIN)); 
2432:  BSF    F92.3
2434:  BTFSS  F80.3
2436:  BRA    243C
2438:  MOVLB  1
243A:  BRA    2338
....................      bip_basla(); 
243C:  MOVLW  32
243E:  MOVLB  1
2440:  MOVWF  x93
2442:  MOVLW  02
2444:  MOVWF  x94
2446:  MOVLW  7C
2448:  MOVWF  x96
244A:  MOVLW  15
244C:  MOVWF  x95
244E:  MOVLB  0
2450:  CALL   08FE
....................       
....................      write_eeprom( EE_ADR_VALF_SURE,sure); 
2454:  MOVF   FF2,W
2456:  MOVWF  00
2458:  BCF    FF2.7
245A:  MOVLW  06
245C:  MOVWF  FA9
245E:  MOVFF  16E,FA8
2462:  BCF    FA6.6
2464:  BCF    FA6.7
2466:  BSF    FA6.2
2468:  MOVLB  F
246A:  MOVLW  55
246C:  MOVWF  FA7
246E:  MOVLW  AA
2470:  MOVWF  FA7
2472:  BSF    FA6.1
2474:  BTFSC  FA6.1
2476:  BRA    2474
2478:  BCF    FA6.2
247A:  MOVF   00,W
247C:  IORWF  FF2,F
....................      valf_sure=sure; 
247E:  MOVFF  16E,56
....................      sure_str=dilTxtGetir(dil_sec,5); 
2482:  MOVFF  60,193
2486:  MOVLW  05
2488:  MOVLB  1
248A:  MOVWF  x94
248C:  MOVLB  0
248E:  CALL   0BF4
2492:  MOVFF  02,16D
2496:  MOVFF  01,16C
....................      printf(lcd_putc,"\f%s",sure_str); 
249A:  MOVLW  0C
249C:  MOVLB  1
249E:  MOVWF  x96
24A0:  MOVLB  0
24A2:  CALL   0842
24A6:  MOVFF  16D,FEA
24AA:  MOVFF  16C,FE9
24AE:  CALL   0EA0
....................       
....................      delay_ms(1000); 
24B2:  MOVLW  04
24B4:  MOVLB  1
24B6:  MOVWF  x6F
24B8:  MOVLW  FA
24BA:  MOVWF  x99
24BC:  MOVLB  0
24BE:  CALL   06CE
24C2:  MOVLB  1
24C4:  DECFSZ x6F,F
24C6:  BRA    24B8
24C8:  MOVLB  0
24CA:  GOTO   27F4 (RETURN)
.................... } 
....................  
.................... void dil_secim_islemi(void){ 
*
1E18:  MOVFF  FF2,193
1E1C:  BCF    FF2.7
1E1E:  MOVLW  10
1E20:  MOVWF  FA9
1E22:  BCF    FA6.6
1E24:  BCF    FA6.7
1E26:  BSF    FA6.0
1E28:  MOVF   FA8,W
1E2A:  MOVLB  1
1E2C:  BTFSC  x93.7
1E2E:  BSF    FF2.7
1E30:  MOVWF  x6C
1E32:  MOVLW  14
1E34:  MOVWF  x6D
....................      
....................     int8 dil=read_eeprom(EE_ADR_DIL_SEC); 
....................     char dil_deg=20; 
....................     char *dil_str; 
....................     if(dil>100) dil=DIL_TR; 
1E36:  MOVF   x6C,W
1E38:  SUBLW  64
1E3A:  BC    1E40
1E3C:  MOVLW  14
1E3E:  MOVWF  x6C
....................      
....................     if(dil==DIL_TR) dil_str=splitStr(lcd_diller, ",", 1); 
1E40:  MOVF   x6C,W
1E42:  SUBLW  14
1E44:  BNZ   1E96
1E46:  MOVLW  01
1E48:  MOVWF  FEA
1E4A:  MOVLW  70
1E4C:  MOVWF  FE9
1E4E:  MOVLW  21
1E50:  MOVWF  01
1E52:  CLRF   FF7
1E54:  MOVLW  00
1E56:  MOVLB  0
1E58:  CALL   0158
1E5C:  TBLRD*-
1E5E:  TBLRD*+
1E60:  MOVFF  FF5,FEE
1E64:  DECFSZ 01,F
1E66:  BRA    1E5E
1E68:  MOVLW  2C
1E6A:  MOVLB  1
1E6C:  MOVWF  x91
1E6E:  CLRF   x92
1E70:  MOVLW  01
1E72:  MOVLB  2
1E74:  MOVWF  x25
1E76:  MOVLW  70
1E78:  MOVWF  x24
1E7A:  MOVLW  01
1E7C:  MOVWF  x27
1E7E:  MOVLW  91
1E80:  MOVWF  x26
1E82:  MOVLW  01
1E84:  MOVWF  x28
1E86:  MOVLB  0
1E88:  CALL   0B8E
1E8C:  MOVFF  02,16F
1E90:  MOVFF  01,16E
1E94:  MOVLB  1
....................     if(dil==DIL_FR) dil_str=splitStr(lcd_diller, ",", 2); 
1E96:  MOVF   x6C,W
1E98:  SUBLW  15
1E9A:  BNZ   1EEC
1E9C:  MOVLW  01
1E9E:  MOVWF  FEA
1EA0:  MOVLW  70
1EA2:  MOVWF  FE9
1EA4:  MOVLW  21
1EA6:  MOVWF  01
1EA8:  CLRF   FF7
1EAA:  MOVLW  00
1EAC:  MOVLB  0
1EAE:  CALL   0158
1EB2:  TBLRD*-
1EB4:  TBLRD*+
1EB6:  MOVFF  FF5,FEE
1EBA:  DECFSZ 01,F
1EBC:  BRA    1EB4
1EBE:  MOVLW  2C
1EC0:  MOVLB  1
1EC2:  MOVWF  x91
1EC4:  CLRF   x92
1EC6:  MOVLW  01
1EC8:  MOVLB  2
1ECA:  MOVWF  x25
1ECC:  MOVLW  70
1ECE:  MOVWF  x24
1ED0:  MOVLW  01
1ED2:  MOVWF  x27
1ED4:  MOVLW  91
1ED6:  MOVWF  x26
1ED8:  MOVLW  02
1EDA:  MOVWF  x28
1EDC:  MOVLB  0
1EDE:  CALL   0B8E
1EE2:  MOVFF  02,16F
1EE6:  MOVFF  01,16E
1EEA:  MOVLB  1
....................     if(dil==DIL_ALM) dil_str=splitStr(lcd_diller, ",", 3); 
1EEC:  MOVF   x6C,W
1EEE:  SUBLW  16
1EF0:  BNZ   1F42
1EF2:  MOVLW  01
1EF4:  MOVWF  FEA
1EF6:  MOVLW  70
1EF8:  MOVWF  FE9
1EFA:  MOVLW  21
1EFC:  MOVWF  01
1EFE:  CLRF   FF7
1F00:  MOVLW  00
1F02:  MOVLB  0
1F04:  CALL   0158
1F08:  TBLRD*-
1F0A:  TBLRD*+
1F0C:  MOVFF  FF5,FEE
1F10:  DECFSZ 01,F
1F12:  BRA    1F0A
1F14:  MOVLW  2C
1F16:  MOVLB  1
1F18:  MOVWF  x91
1F1A:  CLRF   x92
1F1C:  MOVLW  01
1F1E:  MOVLB  2
1F20:  MOVWF  x25
1F22:  MOVLW  70
1F24:  MOVWF  x24
1F26:  MOVLW  01
1F28:  MOVWF  x27
1F2A:  MOVLW  91
1F2C:  MOVWF  x26
1F2E:  MOVLW  03
1F30:  MOVWF  x28
1F32:  MOVLB  0
1F34:  CALL   0B8E
1F38:  MOVFF  02,16F
1F3C:  MOVFF  01,16E
1F40:  MOVLB  1
....................     if(dil==DIL_ING) dil_str=splitStr(lcd_diller, ",", 4); 
1F42:  MOVF   x6C,W
1F44:  SUBLW  17
1F46:  BNZ   1F98
1F48:  MOVLW  01
1F4A:  MOVWF  FEA
1F4C:  MOVLW  70
1F4E:  MOVWF  FE9
1F50:  MOVLW  21
1F52:  MOVWF  01
1F54:  CLRF   FF7
1F56:  MOVLW  00
1F58:  MOVLB  0
1F5A:  CALL   0158
1F5E:  TBLRD*-
1F60:  TBLRD*+
1F62:  MOVFF  FF5,FEE
1F66:  DECFSZ 01,F
1F68:  BRA    1F60
1F6A:  MOVLW  2C
1F6C:  MOVLB  1
1F6E:  MOVWF  x91
1F70:  CLRF   x92
1F72:  MOVLW  01
1F74:  MOVLB  2
1F76:  MOVWF  x25
1F78:  MOVLW  70
1F7A:  MOVWF  x24
1F7C:  MOVLW  01
1F7E:  MOVWF  x27
1F80:  MOVLW  91
1F82:  MOVWF  x26
1F84:  MOVLW  04
1F86:  MOVWF  x28
1F88:  MOVLB  0
1F8A:  CALL   0B8E
1F8E:  MOVFF  02,16F
1F92:  MOVFF  01,16E
1F96:  MOVLB  1
....................      
....................     printf(lcd_putc,"\f%s",dil_str); 
1F98:  MOVLW  0C
1F9A:  MOVWF  x96
1F9C:  MOVLB  0
1F9E:  CALL   0842
1FA2:  MOVFF  16F,FEA
1FA6:  MOVFF  16E,FE9
1FAA:  CALL   0EA0
....................     printf(lcd_putc,"\n<<<    <>    >>>"); 
1FAE:  MOVLW  A4
1FB0:  MOVWF  FF6
1FB2:  MOVLW  05
1FB4:  MOVWF  FF7
1FB6:  CALL   089C
....................     delay_ms(1000); 
1FBA:  MOVLW  04
1FBC:  MOVLB  1
1FBE:  MOVWF  x93
1FC0:  MOVLW  FA
1FC2:  MOVWF  x99
1FC4:  MOVLB  0
1FC6:  CALL   06CE
1FCA:  MOVLB  1
1FCC:  DECFSZ x93,F
1FCE:  BRA    1FC0
....................      
....................     do{ 
....................         lcd_gotoxy(1,1); 
1FD0:  MOVLW  01
1FD2:  MOVWF  x97
1FD4:  MOVWF  x98
1FD6:  MOVLB  0
1FD8:  CALL   081C
....................         printf(lcd_putc,"\f%s",dil_str); 
1FDC:  MOVLW  0C
1FDE:  MOVLB  1
1FE0:  MOVWF  x96
1FE2:  MOVLB  0
1FE4:  CALL   0842
1FE8:  MOVFF  16F,FEA
1FEC:  MOVFF  16E,FE9
1FF0:  CALL   0EA0
....................         printf(lcd_putc,"\n<<<    <>    >>>"); 
1FF4:  MOVLW  B6
1FF6:  MOVWF  FF6
1FF8:  MOVLW  05
1FFA:  MOVWF  FF7
1FFC:  CALL   089C
....................          
....................         if(!input(SOL_BTN_PIN)){ 
2000:  BSF    F92.5
2002:  BTFSC  F80.5
2004:  BRA    203A
....................             delay_ms(100); 
2006:  MOVLW  64
2008:  MOVLB  1
200A:  MOVWF  x99
200C:  MOVLB  0
200E:  CALL   06CE
....................             bip_basla(); 
2012:  MOVLW  32
2014:  MOVLB  1
2016:  MOVWF  x93
2018:  MOVLW  02
201A:  MOVWF  x94
201C:  MOVLW  7C
201E:  MOVWF  x96
2020:  MOVLW  15
2022:  MOVWF  x95
2024:  MOVLB  0
2026:  CALL   08FE
....................             dil_deg--; 
202A:  MOVLB  1
202C:  DECF   x6D,F
....................             if(dil_deg<20) dil_deg=20; 
202E:  MOVF   x6D,W
2030:  SUBLW  13
2032:  BNC   2038
2034:  MOVLW  14
2036:  MOVWF  x6D
2038:  MOVLB  0
....................              
....................         } 
....................         if(!input(SAG_BTN_PIN)){ 
203A:  BSF    F92.2
203C:  BTFSC  F80.2
203E:  BRA    2074
....................             delay_ms(100); 
2040:  MOVLW  64
2042:  MOVLB  1
2044:  MOVWF  x99
2046:  MOVLB  0
2048:  CALL   06CE
....................             bip_basla(); 
204C:  MOVLW  32
204E:  MOVLB  1
2050:  MOVWF  x93
2052:  MOVLW  02
2054:  MOVWF  x94
2056:  MOVLW  7C
2058:  MOVWF  x96
205A:  MOVLW  15
205C:  MOVWF  x95
205E:  MOVLB  0
2060:  CALL   08FE
....................             dil_deg++; 
2064:  MOVLB  1
2066:  INCF   x6D,F
....................             if(dil_deg>23) dil_deg=23; 
2068:  MOVF   x6D,W
206A:  SUBLW  17
206C:  BC    2072
206E:  MOVLW  17
2070:  MOVWF  x6D
2072:  MOVLB  0
....................             
....................         } 
....................          
....................         if(dil_deg==DIL_TR) dil_str=splitStr(lcd_diller, ",", 1); 
2074:  MOVLB  1
2076:  MOVF   x6D,W
2078:  SUBLW  14
207A:  BNZ   20CC
207C:  MOVLW  01
207E:  MOVWF  FEA
2080:  MOVLW  70
2082:  MOVWF  FE9
2084:  MOVLW  21
2086:  MOVWF  01
2088:  CLRF   FF7
208A:  MOVLW  00
208C:  MOVLB  0
208E:  CALL   0158
2092:  TBLRD*-
2094:  TBLRD*+
2096:  MOVFF  FF5,FEE
209A:  DECFSZ 01,F
209C:  BRA    2094
209E:  MOVLW  2C
20A0:  MOVLB  1
20A2:  MOVWF  x91
20A4:  CLRF   x92
20A6:  MOVLW  01
20A8:  MOVLB  2
20AA:  MOVWF  x25
20AC:  MOVLW  70
20AE:  MOVWF  x24
20B0:  MOVLW  01
20B2:  MOVWF  x27
20B4:  MOVLW  91
20B6:  MOVWF  x26
20B8:  MOVLW  01
20BA:  MOVWF  x28
20BC:  MOVLB  0
20BE:  CALL   0B8E
20C2:  MOVFF  02,16F
20C6:  MOVFF  01,16E
20CA:  MOVLB  1
....................         if(dil_deg==DIL_FR) dil_str=splitStr(lcd_diller, ",", 2); 
20CC:  MOVF   x6D,W
20CE:  SUBLW  15
20D0:  BNZ   2122
20D2:  MOVLW  01
20D4:  MOVWF  FEA
20D6:  MOVLW  70
20D8:  MOVWF  FE9
20DA:  MOVLW  21
20DC:  MOVWF  01
20DE:  CLRF   FF7
20E0:  MOVLW  00
20E2:  MOVLB  0
20E4:  CALL   0158
20E8:  TBLRD*-
20EA:  TBLRD*+
20EC:  MOVFF  FF5,FEE
20F0:  DECFSZ 01,F
20F2:  BRA    20EA
20F4:  MOVLW  2C
20F6:  MOVLB  1
20F8:  MOVWF  x91
20FA:  CLRF   x92
20FC:  MOVLW  01
20FE:  MOVLB  2
2100:  MOVWF  x25
2102:  MOVLW  70
2104:  MOVWF  x24
2106:  MOVLW  01
2108:  MOVWF  x27
210A:  MOVLW  91
210C:  MOVWF  x26
210E:  MOVLW  02
2110:  MOVWF  x28
2112:  MOVLB  0
2114:  CALL   0B8E
2118:  MOVFF  02,16F
211C:  MOVFF  01,16E
2120:  MOVLB  1
....................         if(dil_deg==DIL_ALM) dil_str=splitStr(lcd_diller, ",", 3); 
2122:  MOVF   x6D,W
2124:  SUBLW  16
2126:  BNZ   2178
2128:  MOVLW  01
212A:  MOVWF  FEA
212C:  MOVLW  70
212E:  MOVWF  FE9
2130:  MOVLW  21
2132:  MOVWF  01
2134:  CLRF   FF7
2136:  MOVLW  00
2138:  MOVLB  0
213A:  CALL   0158
213E:  TBLRD*-
2140:  TBLRD*+
2142:  MOVFF  FF5,FEE
2146:  DECFSZ 01,F
2148:  BRA    2140
214A:  MOVLW  2C
214C:  MOVLB  1
214E:  MOVWF  x91
2150:  CLRF   x92
2152:  MOVLW  01
2154:  MOVLB  2
2156:  MOVWF  x25
2158:  MOVLW  70
215A:  MOVWF  x24
215C:  MOVLW  01
215E:  MOVWF  x27
2160:  MOVLW  91
2162:  MOVWF  x26
2164:  MOVLW  03
2166:  MOVWF  x28
2168:  MOVLB  0
216A:  CALL   0B8E
216E:  MOVFF  02,16F
2172:  MOVFF  01,16E
2176:  MOVLB  1
....................         if(dil_deg==DIL_ING) dil_str=splitStr(lcd_diller, ",", 4); 
2178:  MOVF   x6D,W
217A:  SUBLW  17
217C:  BNZ   21CE
217E:  MOVLW  01
2180:  MOVWF  FEA
2182:  MOVLW  70
2184:  MOVWF  FE9
2186:  MOVLW  21
2188:  MOVWF  01
218A:  CLRF   FF7
218C:  MOVLW  00
218E:  MOVLB  0
2190:  CALL   0158
2194:  TBLRD*-
2196:  TBLRD*+
2198:  MOVFF  FF5,FEE
219C:  DECFSZ 01,F
219E:  BRA    2196
21A0:  MOVLW  2C
21A2:  MOVLB  1
21A4:  MOVWF  x91
21A6:  CLRF   x92
21A8:  MOVLW  01
21AA:  MOVLB  2
21AC:  MOVWF  x25
21AE:  MOVLW  70
21B0:  MOVWF  x24
21B2:  MOVLW  01
21B4:  MOVWF  x27
21B6:  MOVLW  91
21B8:  MOVWF  x26
21BA:  MOVLW  04
21BC:  MOVWF  x28
21BE:  MOVLB  0
21C0:  CALL   0B8E
21C4:  MOVFF  02,16F
21C8:  MOVFF  01,16E
21CC:  MOVLB  1
....................          
....................         delay_ms(100); 
21CE:  MOVLW  64
21D0:  MOVWF  x99
21D2:  MOVLB  0
21D4:  CALL   06CE
....................     } while(input(ORTA_BTN_PIN)); 
21D8:  BSF    F92.3
21DA:  BTFSS  F80.3
21DC:  BRA    21E2
21DE:  MOVLB  1
21E0:  BRA    1FD0
....................      bip_basla(); 
21E2:  MOVLW  32
21E4:  MOVLB  1
21E6:  MOVWF  x93
21E8:  MOVLW  02
21EA:  MOVWF  x94
21EC:  MOVLW  7C
21EE:  MOVWF  x96
21F0:  MOVLW  15
21F2:  MOVWF  x95
21F4:  MOVLB  0
21F6:  CALL   08FE
....................       
....................      write_eeprom(EE_ADR_DIL_SEC,dil_deg); 
21FA:  MOVF   FF2,W
21FC:  MOVWF  00
21FE:  BCF    FF2.7
2200:  MOVLW  10
2202:  MOVWF  FA9
2204:  MOVFF  16D,FA8
2208:  BCF    FA6.6
220A:  BCF    FA6.7
220C:  BSF    FA6.2
220E:  MOVLB  F
2210:  MOVLW  55
2212:  MOVWF  FA7
2214:  MOVLW  AA
2216:  MOVWF  FA7
2218:  BSF    FA6.1
221A:  BTFSC  FA6.1
221C:  BRA    221A
221E:  BCF    FA6.2
2220:  MOVF   00,W
2222:  IORWF  FF2,F
....................      dil_str=dilTxtGetir(dil_deg,5); 
2224:  MOVFF  16D,193
2228:  MOVLW  05
222A:  MOVLB  1
222C:  MOVWF  x94
222E:  MOVLB  0
2230:  CALL   0BF4
2234:  MOVFF  02,16F
2238:  MOVFF  01,16E
....................      printf(lcd_putc,"\f!!%s!!",dil_str); 
223C:  MOVLW  C8
223E:  MOVWF  FF6
2240:  MOVLW  05
2242:  MOVWF  FF7
2244:  MOVLW  03
2246:  MOVLB  1
2248:  MOVWF  x93
224A:  MOVLB  0
224C:  CALL   1016
2250:  MOVFF  16F,FEA
2254:  MOVFF  16E,FE9
2258:  CALL   0EA0
225C:  MOVLW  21
225E:  MOVLB  1
2260:  MOVWF  x96
2262:  MOVLB  0
2264:  CALL   0842
2268:  MOVLW  21
226A:  MOVLB  1
226C:  MOVWF  x96
226E:  MOVLB  0
2270:  CALL   0842
....................      dil_sec=dil_deg; 
2274:  MOVFF  16D,60
....................      delay_ms(1000); 
2278:  MOVLW  04
227A:  MOVLB  1
227C:  MOVWF  x93
227E:  MOVLW  FA
2280:  MOVWF  x99
2282:  MOVLB  0
2284:  CALL   06CE
2288:  MOVLB  1
228A:  DECFSZ x93,F
228C:  BRA    227E
228E:  MOVLB  0
2290:  GOTO   2782 (RETURN)
.................... } 
....................  
.................... void lcdMenuIslem(void) { 
*
24CE:  MOVLB  1
24D0:  CLRF   x69
....................      
....................     signed int btn = 0; 
....................     char *menu_str; 
....................     printf(lcd_putc, "\f      MENU");        //Butun dillerde ayný 
24D2:  MOVLW  D0
24D4:  MOVWF  FF6
24D6:  MOVLW  05
24D8:  MOVWF  FF7
24DA:  MOVLB  0
24DC:  CALL   089C
....................     printf(lcd_putc, "\n<<<    <>    >>>"); 
24E0:  MOVLW  DC
24E2:  MOVWF  FF6
24E4:  MOVLW  05
24E6:  MOVWF  FF7
24E8:  CALL   089C
....................     delay_ms(1000); 
24EC:  MOVLW  04
24EE:  MOVLB  1
24F0:  MOVWF  x6C
24F2:  MOVLW  FA
24F4:  MOVWF  x99
24F6:  MOVLB  0
24F8:  CALL   06CE
24FC:  MOVLB  1
24FE:  DECFSZ x6C,F
2500:  BRA    24F2
....................     duty = 0; 
2502:  MOVLB  0
2504:  CLRF   x6C
2506:  CLRF   x6B
....................      
....................     while (1) { 
....................  
....................         if (!input(SAG_BTN_PIN)) { 
2508:  BSF    F92.2
250A:  BTFSC  F80.2
250C:  BRA    2542
....................             delay_ms(150); 
250E:  MOVLW  96
2510:  MOVLB  1
2512:  MOVWF  x99
2514:  MOVLB  0
2516:  CALL   06CE
....................             btn++; 
251A:  MOVLB  1
251C:  INCF   x69,F
....................             if (btn > MAX_MENU_DEGER)btn = 1; 
251E:  BTFSC  x69.7
2520:  BRA    252C
2522:  MOVF   x69,W
2524:  SUBLW  06
2526:  BC    252C
2528:  MOVLW  01
252A:  MOVWF  x69
....................             bip_basla(); 
252C:  MOVLW  32
252E:  MOVWF  x93
2530:  MOVLW  02
2532:  MOVWF  x94
2534:  MOVLW  7C
2536:  MOVWF  x96
2538:  MOVLW  15
253A:  MOVWF  x95
253C:  MOVLB  0
253E:  CALL   08FE
....................         } 
....................  
....................         if (!input(SOL_BTN_PIN)) { 
2542:  BSF    F92.5
2544:  BTFSC  F80.5
2546:  BRA    257C
....................             delay_ms(150); 
2548:  MOVLW  96
254A:  MOVLB  1
254C:  MOVWF  x99
254E:  MOVLB  0
2550:  CALL   06CE
....................             btn--; 
2554:  MOVLB  1
2556:  DECF   x69,F
....................             if (btn <= 0)btn = MAX_MENU_DEGER; 
2558:  BTFSC  x69.7
255A:  BRA    2562
255C:  MOVF   x69,W
255E:  SUBLW  00
2560:  BNC   2566
2562:  MOVLW  06
2564:  MOVWF  x69
....................             bip_basla(); 
2566:  MOVLW  32
2568:  MOVWF  x93
256A:  MOVLW  02
256C:  MOVWF  x94
256E:  MOVLW  7C
2570:  MOVWF  x96
2572:  MOVLW  15
2574:  MOVWF  x95
2576:  MOVLB  0
2578:  CALL   08FE
....................         } 
....................          
....................         if(btn==1)      //Sure Ayarý 
257C:  MOVLB  1
257E:  DECFSZ x69,W
2580:  BRA    25FC
....................         { 
....................              menu_str=dilTxtGetir(dil_sec,6); 
2582:  MOVFF  60,193
2586:  MOVLW  06
2588:  MOVWF  x94
258A:  MOVLB  0
258C:  CALL   0BF4
2590:  MOVFF  02,16B
2594:  MOVFF  01,16A
....................  
....................              printf(lcd_putc,"\f %s",menu_str); 
2598:  MOVLW  0C
259A:  MOVLB  1
259C:  MOVWF  x96
259E:  MOVLB  0
25A0:  CALL   0842
25A4:  MOVLW  20
25A6:  MOVLB  1
25A8:  MOVWF  x96
25AA:  MOVLB  0
25AC:  CALL   0842
25B0:  MOVFF  16B,FEA
25B4:  MOVFF  16A,FE9
25B8:  CALL   0EA0
....................              printf(lcd_putc,"\n<<<    <>    >>>"); 
25BC:  MOVLW  EE
25BE:  MOVWF  FF6
25C0:  MOVLW  05
25C2:  MOVWF  FF7
25C4:  CALL   089C
....................               
....................              if(!input(ORTA_BTN_PIN)){ 
25C8:  BSF    F92.3
25CA:  BTFSC  F80.3
25CC:  BRA    25FE
....................                 delay_ms(100); 
25CE:  MOVLW  64
25D0:  MOVLB  1
25D2:  MOVWF  x99
25D4:  MOVLB  0
25D6:  CALL   06CE
....................                 bip_basla(); 
25DA:  MOVLW  32
25DC:  MOVLB  1
25DE:  MOVWF  x93
25E0:  MOVLW  02
25E2:  MOVWF  x94
25E4:  MOVLW  7C
25E6:  MOVWF  x96
25E8:  MOVLW  15
25EA:  MOVWF  x95
25EC:  MOVLB  0
25EE:  CALL   08FE
....................                 sureAyar(); 
25F2:  GOTO   11D6
....................                 btn=2; 
25F6:  MOVLW  02
25F8:  MOVLB  1
25FA:  MOVWF  x69
25FC:  MOVLB  0
....................              } 
....................         } 
....................          
....................         if(btn==2)      //Bekleme Sure Ayarý 
25FE:  MOVLB  1
2600:  MOVF   x69,W
2602:  SUBLW  02
2604:  BNZ   2680
....................         { 
....................              menu_str=dilTxtGetir(dil_sec,12); 
2606:  MOVFF  60,193
260A:  MOVLW  0C
260C:  MOVWF  x94
260E:  MOVLB  0
2610:  CALL   0BF4
2614:  MOVFF  02,16B
2618:  MOVFF  01,16A
....................  
....................              printf(lcd_putc,"\f %s",menu_str); 
261C:  MOVLW  0C
261E:  MOVLB  1
2620:  MOVWF  x96
2622:  MOVLB  0
2624:  CALL   0842
2628:  MOVLW  20
262A:  MOVLB  1
262C:  MOVWF  x96
262E:  MOVLB  0
2630:  CALL   0842
2634:  MOVFF  16B,FEA
2638:  MOVFF  16A,FE9
263C:  CALL   0EA0
....................              printf(lcd_putc,"\n<<<    <>    >>>"); 
2640:  MOVLW  00
2642:  MOVWF  FF6
2644:  MOVLW  06
2646:  MOVWF  FF7
2648:  CALL   089C
....................               
....................              if(!input(ORTA_BTN_PIN)){ 
264C:  BSF    F92.3
264E:  BTFSC  F80.3
2650:  BRA    2682
....................                 delay_ms(100); 
2652:  MOVLW  64
2654:  MOVLB  1
2656:  MOVWF  x99
2658:  MOVLB  0
265A:  CALL   06CE
....................                 bip_basla(); 
265E:  MOVLW  32
2660:  MOVLB  1
2662:  MOVWF  x93
2664:  MOVLW  02
2666:  MOVWF  x94
2668:  MOVLW  7C
266A:  MOVWF  x96
266C:  MOVLW  15
266E:  MOVWF  x95
2670:  MOVLB  0
2672:  CALL   08FE
....................                 beklemeSureAyar(); 
2676:  GOTO   13D4
....................                 btn=3; 
267A:  MOVLW  03
267C:  MOVLB  1
267E:  MOVWF  x69
2680:  MOVLB  0
....................              } 
....................         } 
....................          
....................         if(btn==3)  //DONANIM KONT. 
2682:  MOVLB  1
2684:  MOVF   x69,W
2686:  SUBLW  03
2688:  BNZ   2704
....................         { 
....................             menu_str=dilTxtGetir(dil_sec,7); 
268A:  MOVFF  60,193
268E:  MOVLW  07
2690:  MOVWF  x94
2692:  MOVLB  0
2694:  CALL   0BF4
2698:  MOVFF  02,16B
269C:  MOVFF  01,16A
....................             printf(lcd_putc,"\f %s",menu_str); 
26A0:  MOVLW  0C
26A2:  MOVLB  1
26A4:  MOVWF  x96
26A6:  MOVLB  0
26A8:  CALL   0842
26AC:  MOVLW  20
26AE:  MOVLB  1
26B0:  MOVWF  x96
26B2:  MOVLB  0
26B4:  CALL   0842
26B8:  MOVFF  16B,FEA
26BC:  MOVFF  16A,FE9
26C0:  CALL   0EA0
....................             printf(lcd_putc,"\n<<<    <>    >>>"); 
26C4:  MOVLW  12
26C6:  MOVWF  FF6
26C8:  MOVLW  06
26CA:  MOVWF  FF7
26CC:  CALL   089C
....................               
....................              if(!input(ORTA_BTN_PIN)){ 
26D0:  BSF    F92.3
26D2:  BTFSC  F80.3
26D4:  BRA    2706
....................                 delay_ms(100); 
26D6:  MOVLW  64
26D8:  MOVLB  1
26DA:  MOVWF  x99
26DC:  MOVLB  0
26DE:  CALL   06CE
....................                 bip_basla(); 
26E2:  MOVLW  32
26E4:  MOVLB  1
26E6:  MOVWF  x93
26E8:  MOVLW  02
26EA:  MOVWF  x94
26EC:  MOVLW  7C
26EE:  MOVWF  x96
26F0:  MOVLW  15
26F2:  MOVWF  x95
26F4:  MOVLB  0
26F6:  CALL   08FE
....................                 donanim_kontrol(); 
26FA:  GOTO   16A0
....................                 btn=4; 
26FE:  MOVLW  04
2700:  MOVLB  1
2702:  MOVWF  x69
2704:  MOVLB  0
....................              } 
....................         } 
....................         if(btn==4)//DIL SEC 
2706:  MOVLB  1
2708:  MOVF   x69,W
270A:  SUBLW  04
270C:  BNZ   2788
....................         { 
....................             menu_str=dilTxtGetir(dil_sec,8); 
270E:  MOVFF  60,193
2712:  MOVLW  08
2714:  MOVWF  x94
2716:  MOVLB  0
2718:  CALL   0BF4
271C:  MOVFF  02,16B
2720:  MOVFF  01,16A
....................             printf(lcd_putc,"\f %s",menu_str); 
2724:  MOVLW  0C
2726:  MOVLB  1
2728:  MOVWF  x96
272A:  MOVLB  0
272C:  CALL   0842
2730:  MOVLW  20
2732:  MOVLB  1
2734:  MOVWF  x96
2736:  MOVLB  0
2738:  CALL   0842
273C:  MOVFF  16B,FEA
2740:  MOVFF  16A,FE9
2744:  CALL   0EA0
....................             printf(lcd_putc,"\n<<<    <>    >>>"); 
2748:  MOVLW  24
274A:  MOVWF  FF6
274C:  MOVLW  06
274E:  MOVWF  FF7
2750:  CALL   089C
....................               
....................             if(!input(ORTA_BTN_PIN)){ 
2754:  BSF    F92.3
2756:  BTFSC  F80.3
2758:  BRA    278A
....................                 delay_ms(100); 
275A:  MOVLW  64
275C:  MOVLB  1
275E:  MOVWF  x99
2760:  MOVLB  0
2762:  CALL   06CE
....................                 bip_basla(); 
2766:  MOVLW  32
2768:  MOVLB  1
276A:  MOVWF  x93
276C:  MOVLW  02
276E:  MOVWF  x94
2770:  MOVLW  7C
2772:  MOVWF  x96
2774:  MOVLW  15
2776:  MOVWF  x95
2778:  MOVLB  0
277A:  CALL   08FE
....................                 dil_secim_islemi(); 
277E:  GOTO   1E18
....................                 btn=5; 
2782:  MOVLW  05
2784:  MOVLB  1
2786:  MOVWF  x69
2788:  MOVLB  0
....................             } 
....................         } 
....................          
....................         if(btn==5)  //VALf Sure 
278A:  MOVLB  1
278C:  MOVF   x69,W
278E:  SUBLW  05
2790:  BNZ   27FA
....................         { 
....................             menu_str="VALF SURE";   //dilTxtGetir(dil_sec,12); 
2792:  MOVLW  56
2794:  MOVWF  x6A
2796:  MOVLW  41
2798:  MOVWF  x6B
....................  
....................              printf(lcd_putc,"\f %s","VALF SURE"); 
279A:  MOVLW  0C
279C:  MOVWF  x96
279E:  MOVLB  0
27A0:  CALL   0842
27A4:  MOVLW  20
27A6:  MOVLB  1
27A8:  MOVWF  x96
27AA:  MOVLB  0
27AC:  CALL   0842
27B0:  MOVLW  36
27B2:  MOVWF  FF6
27B4:  MOVLW  06
27B6:  MOVWF  FF7
27B8:  CALL   089C
....................              printf(lcd_putc,"\n<<<    <>    >>>"); 
27BC:  MOVLW  40
27BE:  MOVWF  FF6
27C0:  MOVLW  06
27C2:  MOVWF  FF7
27C4:  CALL   089C
....................               
....................              if(!input(ORTA_BTN_PIN)){ 
27C8:  BSF    F92.3
27CA:  BTFSC  F80.3
27CC:  BRA    27FC
....................                 delay_ms(100); 
27CE:  MOVLW  64
27D0:  MOVLB  1
27D2:  MOVWF  x99
27D4:  MOVLB  0
27D6:  CALL   06CE
....................                 bip_basla(); 
27DA:  MOVLW  32
27DC:  MOVLB  1
27DE:  MOVWF  x93
27E0:  MOVLW  02
27E2:  MOVWF  x94
27E4:  MOVLW  7C
27E6:  MOVWF  x96
27E8:  MOVLW  15
27EA:  MOVWF  x95
27EC:  MOVLB  0
27EE:  CALL   08FE
....................                 valfSureAyar(); 
27F2:  BRA    2294
....................                 btn=6; 
27F4:  MOVLW  06
27F6:  MOVLB  1
27F8:  MOVWF  x69
27FA:  MOVLB  0
....................              } 
....................         } 
....................         if(btn==6)  //CIKIS 
27FC:  MOVLB  1
27FE:  MOVF   x69,W
2800:  SUBLW  06
2802:  BNZ   2862
....................         { 
....................             menu_str=dilTxtGetir(dil_sec,9); 
2804:  MOVFF  60,193
2808:  MOVLW  09
280A:  MOVWF  x94
280C:  MOVLB  0
280E:  CALL   0BF4
2812:  MOVFF  02,16B
2816:  MOVFF  01,16A
....................             printf(lcd_putc,"\f %s",menu_str); 
281A:  MOVLW  0C
281C:  MOVLB  1
281E:  MOVWF  x96
2820:  MOVLB  0
2822:  CALL   0842
2826:  MOVLW  20
2828:  MOVLB  1
282A:  MOVWF  x96
282C:  MOVLB  0
282E:  CALL   0842
2832:  MOVFF  16B,FEA
2836:  MOVFF  16A,FE9
283A:  CALL   0EA0
....................             printf(lcd_putc,"\n<<<    <>    >>>"); 
283E:  MOVLW  52
2840:  MOVWF  FF6
2842:  MOVLW  06
2844:  MOVWF  FF7
2846:  CALL   089C
....................             if(!input(ORTA_BTN_PIN)){ 
284A:  BSF    F92.3
284C:  BTFSC  F80.3
284E:  BRA    2864
....................                 delay_ms(250); 
2850:  MOVLW  FA
2852:  MOVLB  1
2854:  MOVWF  x99
2856:  MOVLB  0
2858:  CALL   06CE
....................                 btn=0; 
285C:  MOVLB  1
285E:  CLRF   x69
....................                 break; 
2860:  BRA    2874
2862:  MOVLB  0
....................             } 
....................         } 
....................          
....................         delay_ms(250); 
2864:  MOVLW  FA
2866:  MOVLB  1
2868:  MOVWF  x99
286A:  MOVLB  0
286C:  CALL   06CE
2870:  BRA    2508
2872:  MOVLB  1
....................     }//while 
....................      
....................     lcd_msg_baslik=dilTxtGetir(dil_sec,1); 
2874:  MOVFF  60,193
2878:  MOVLW  01
287A:  MOVWF  x94
287C:  MOVLB  0
287E:  CALL   0BF4
2882:  MOVFF  02,62
2886:  MOVFF  01,61
288A:  GOTO   32D6 (RETURN)
....................     //printf(lcd_putc,"\fOTO DEZENFEKTE"); 
....................     //printf(lcd_putc,"\nDepo : ORTA"); 
.................... } 
....................  
.................... #include "donanim_kont.c" 
.................... #include "tanimlamalar.h" 
.................... /*  
....................  * File:   tanimlamalar.h 
....................  * Author: ilyas 
....................  * 
....................  * Created on 22 Nisan 2020 Çarþamba, 12:49 
....................  */ 
....................  
.................... #ifndef TANIMLAMALAR_H 
.................... #define	TANIMLAMALAR_H 
....................  
.................... #ifdef	__cplusplus 
.................... extern "C" { 
.................... #endif 
....................      
....................     #define MAX_DUTY    800 
....................  
....................     #define LED_PIN   PIN_A4 
....................  
....................     #define pcb_led_yak() output_low(LED_PIN); 
....................     #define pcb_led_son() output_high(LED_PIN); 
....................      
....................  
....................     #define SOL_BTN_PIN     PIN_A5 
....................     #define ORTA_BTN_PIN    PIN_A3 
....................     #define SAG_BTN_PIN     PIN_A2 
....................  
....................     #define GEC_LED_PIN     PIN_A6 
....................     #define DUR_LED_PIN     PIN_A7 
....................  
....................     #define SEVIYE_SENS1_PIN   PIN_E0 
....................     #define SEVIYE_SENS2_PIN   PIN_E1 
....................     #define SEVIYE_SENS3_PIN   PIN_E2 
....................  
....................     #define SEVIYE_LED1_PIN     PIN_B2 
....................     #define SEVIYE_LED2_PIN     PIN_B3 
.................... //    #define SEVIYE_LED3_PIN     PIN_B4 
.................... //    #define SEVIYE_LED4_PIN     PIN_B5 
....................     #define GEC2_LED_PIN     PIN_B4 
....................     #define DUR2_LED_PIN     PIN_B5 
....................  
....................     #define GIR_SENS1_PIN   PIN_B0 
....................     #define GIR_SENS2_PIN   PIN_B1 
....................      
....................     #define ROLE_PIN        PIN_C0 
....................     #define VALF_ROLE_PIN   PIN_C1   
....................  
....................     #define BUZZER_PIN  PIN_C5 
....................      
....................     #define MOTOR_PIN   PIN_C2 
....................  
....................     #define EE_ADR_SURE         0x00 
....................     #define EE_ADR_KUL_SAY_BL   0x01 
....................     #define EE_ADR_KUL_SAY_B2   0x02 
....................     #define EE_ADR_KUL_SAY_B3   0x03 
....................     #define EE_ADR_KUL_SAY_BH   0x04 
....................     #define EE_ADR_BEKLEME_SURE 0x05 
....................     #define EE_ADR_VALF_SURE    0x06 
....................     #define EE_ADR_DIL_SEC      0x10 
....................  
....................      
....................  
....................     #define GIR1_GIR2    1 
....................     #define GIR2_GIR1    2 
....................     #define GIRIS_YOK    0 
....................  
....................     #define DEPO_BOS    10 
....................     #define DEPO_MIN    11 
....................     #define DEPO_ORTA   12 
....................     #define DEPO_MAX    13 
....................  
....................     #define DIL_TR      20 
....................     #define DIL_FR      21 
....................     #define DIL_ALM     22 
....................     #define DIL_ING     23 
....................  
....................     #define KUL_SAY_EE_KAYDET 'K' 
....................     #define KUL_SAY_EE_OKU    'O' 
....................  
....................     #define bip_bekle() bipp(10,10,BUZZER_PIN) //sure,sayi,pin 
....................     #define bip_basla() bipp(50,2,BUZZER_PIN);  //sure,sayi,pin    
....................     #define bip_giris() bipp(100,5,BUZZER_PIN);  //sure,sayi,pin 
....................     #define bip_hata() bipp(250,5,BUZZER_PIN); 
....................  
....................     #define valfOn()  output_high(VALF_ROLE_PIN);   // basýncý boþaltýr Normalde kapalý valf  
....................     #define valfOff()  output_low(VALF_ROLE_PIN);   // basýncý tutar  Normalde kapalý valf  
....................  
....................  
.................... #ifdef	__cplusplus 
.................... } 
.................... #endif 
....................  
.................... #endif	/* TANIMLAMALAR_H */ 
....................  
....................  
....................  
....................  
....................  
....................  
.................... void main() { 
288E:  CLRF   FF8
2890:  BSF    FF1.2
2892:  BSF    FD0.7
2894:  BSF    07.7
2896:  MOVLW  70
2898:  MOVWF  FD3
289A:  BSF    F9B.6
289C:  BCF    F9B.7
289E:  CLRF   31
28A0:  CLRF   30
28A2:  CLRF   2F
28A4:  CLRF   2E
28A6:  CLRF   39
28A8:  CLRF   38
28AA:  CLRF   3B
28AC:  CLRF   3A
28AE:  CLRF   3D
28B0:  CLRF   3C
28B2:  CLRF   3F
28B4:  CLRF   3E
28B6:  CLRF   40
28B8:  CLRF   44
28BA:  CLRF   43
28BC:  CLRF   42
28BE:  CLRF   41
28C0:  CLRF   48
28C2:  CLRF   47
28C4:  CLRF   46
28C6:  CLRF   45
28C8:  CLRF   4C
28CA:  CLRF   4B
28CC:  CLRF   4A
28CE:  CLRF   49
28D0:  CLRF   50
28D2:  CLRF   4F
28D4:  CLRF   4E
28D6:  CLRF   4D
28D8:  CLRF   54
28DA:  CLRF   53
28DC:  CLRF   52
28DE:  CLRF   51
28E0:  CLRF   55
28E2:  MOVLW  01
28E4:  MOVWF  56
28E6:  CLRF   57
28E8:  CLRF   58
28EA:  MOVLW  0A
28EC:  MOVWF  59
28EE:  CLRF   5B
28F0:  CLRF   5A
28F2:  CLRF   5D
28F4:  CLRF   5C
28F6:  CLRF   5F
28F8:  CLRF   5E
28FA:  CLRF   x60
28FC:  CLRF   x6C
28FE:  CLRF   x6B
2900:  CLRF   x6E
2902:  CLRF   x6D
2904:  MOVLB  F
2906:  CLRF   x38
2908:  CLRF   x39
290A:  CLRF   x3A
290C:  CLRF   x3B
290E:  CLRF   x3C
2910:  CLRF   F77
2912:  CLRF   F78
2914:  CLRF   F79
2916:  BRA    2922
2918:  DATA 02,00
291A:  DATA 32,00
291C:  DATA 00,FA
291E:  DATA 40,6F
2920:  DATA 00,00
2922:  MOVLW  00
2924:  MOVWF  FF8
2926:  MOVLW  29
2928:  MOVWF  FF7
292A:  MOVLW  18
292C:  MOVWF  FF6
292E:  TBLRD*+
2930:  MOVF   FF5,W
2932:  MOVWF  00
2934:  XORLW  00
2936:  BZ    295E
2938:  TBLRD*+
293A:  MOVF   FF5,W
293C:  MOVWF  01
293E:  BTFSC  FE8.7
2940:  BRA    294C
2942:  ANDLW  0F
2944:  MOVWF  FEA
2946:  TBLRD*+
2948:  MOVFF  FF5,FE9
294C:  BTFSC  01.6
294E:  TBLRD*+
2950:  BTFSS  01.6
2952:  TBLRD*+
2954:  MOVFF  FF5,FEE
2958:  DCFSNZ 00,F
295A:  BRA    292E
295C:  BRA    2950
295E:  CLRF   FF8
....................     setup_oscillator(OSC_64MHZ); 
2960:  MOVLW  70
2962:  MOVWF  FD3
2964:  BSF    F9B.6
2966:  BCF    F9B.7
....................  
....................     setup_dac(DAC_OFF); 
2968:  CLRF   x41
....................     setup_comparator(NC_NC_NC_NC); 
296A:  CLRF   F77
296C:  MOVLW  04
296E:  MOVWF  F78
2970:  MOVWF  F79
....................     setup_vref(FALSE); 
2972:  CLRF   x42
....................     //setup_adc(ADC_OFF); 
....................  
....................     setup_ccp2(CCP_OFF); 
2974:  MOVLW  F0
2976:  ANDWF  F66,F
....................     setup_ccp3(CCP_OFF); 
2978:  ANDWF  x5D,F
....................     setup_ccp4(CCP_OFF); 
297A:  ANDWF  x57,F
....................     setup_ccp5(CCP_OFF); 
297C:  ANDWF  x54,F
....................  
....................     setup_timer_1(T1_DISABLED); 
297E:  CLRF   FCD
2980:  CLRF   FCC
....................     setup_timer_2(T2_DIV_BY_16, 199, 1); //5Khz max PWM deger=200 peryot kadar osilaskop sonucu 22.01.20 bu uygulamada olmadý 
2982:  MOVLW  00
2984:  IORLW  06
2986:  MOVWF  FBA
2988:  MOVLW  C7
298A:  MOVWF  FBB
....................     // 17.01.2020 : Ugulamada  700 deðeri hesaplamaya göre görüldü 22.01.20 evet.... 
....................     // excell hesabýnda %50 duty deðeri 400 çýkýyor. 5KHz PWM  
....................     // **uygulamada ölçüldü max deger 800 22/04/20   
....................  
....................     //setup_ccp1(CCP_PWM); 
....................     setup_ccp1(CCP_OFF); 
298C:  MOVLW  F0
298E:  ANDWF  FBD,F
....................  
....................     setup_timer_4(T4_DISABLED, 0, 1); 
2990:  MOVLW  00
2992:  MOVWF  x51
2994:  MOVLW  00
2996:  MOVWF  x52
....................     setup_timer_5(T5_DISABLED); 
2998:  CLRF   x4D
299A:  CLRF   x4E
....................     setup_timer_6(T6_DISABLED, 0, 1); 
299C:  MOVWF  x4A
299E:  MOVLW  00
29A0:  MOVWF  x4B
....................  
....................  
....................     setup_adc(ADC_CLOCK_INTERNAL); //  9 bit (max 511) okuyan adc bu þekilde 10 bit oldu..... 
29A2:  MOVF   FC0,W
29A4:  ANDLW  C0
29A6:  IORLW  07
29A8:  MOVWF  FC0
29AA:  BSF    FC0.7
29AC:  BSF    FC2.0
....................     setup_adc_ports(sAN5 | sAN6 | sAN7, VSS_VDD); 
29AE:  MOVF   FC1,W
29B0:  ANDLW  F0
29B2:  MOVWF  FC1
29B4:  MOVLW  00
29B6:  MOVWF  x38
29B8:  MOVLW  07
29BA:  MOVWF  x3C
29BC:  MOVLW  00
29BE:  MOVWF  x39
29C0:  MOVWF  x3A
29C2:  MOVWF  x3B
....................     //setup_adc_ports(AN0_TO_AN1);   //18f4520 
....................     // setup_adc(ADC_CLOCK_DIV_8); 
....................  
....................     //    set_tris_a(0b00101111); 
....................     //    set_tris_b(0b00000011); 
....................     //    set_tris_c(0b10000000); 
....................     //    set_tris_d(0b10000000); 
....................     //    set_tris_e(0b1111); 
....................  
....................     timer_kur(); 
29C4:  MOVLB  0
29C6:  GOTO   06BA
....................  
....................     set_pwm1_duty(0); 
29CA:  CLRF   FBE
....................  
....................     lcd_init(); // Always call this first. 
29CC:  GOTO   07AC
....................     printf(lcd_putc, "\f  ..LYS-2020.."); 
29D0:  MOVLW  64
29D2:  MOVWF  FF6
29D4:  MOVLW  06
29D6:  MOVWF  FF7
29D8:  CALL   089C
....................     printf(lcd_putc, "\n  __YOYUNCAK__"); 
29DC:  MOVLW  74
29DE:  MOVWF  FF6
29E0:  MOVLW  06
29E2:  MOVWF  FF7
29E4:  CALL   089C
....................  
....................     output_a(0x00); 
29E8:  CLRF   F92
29EA:  CLRF   F89
....................  
....................     pcb_led_yak(); 
29EC:  BCF    F92.4
29EE:  BCF    F89.4
....................     delay_ms(1000); 
29F0:  MOVLW  04
29F2:  MOVLB  1
29F4:  MOVWF  x69
29F6:  MOVLW  FA
29F8:  MOVWF  x99
29FA:  MOVLB  0
29FC:  CALL   06CE
2A00:  MOVLB  1
2A02:  DECFSZ x69,F
2A04:  BRA    29F6
....................     pcb_led_son(); 
2A06:  BCF    F92.4
2A08:  BSF    F89.4
....................     delay_ms(1000); 
2A0A:  MOVLW  04
2A0C:  MOVWF  x69
2A0E:  MOVLW  FA
2A10:  MOVWF  x99
2A12:  MOVLB  0
2A14:  CALL   06CE
2A18:  MOVLB  1
2A1A:  DECFSZ x69,F
2A1C:  BRA    2A0E
....................  
....................     dezen_sure = read_eeprom(EE_ADR_SURE); //mS 
2A1E:  MOVFF  FF2,169
2A22:  BCF    FF2.7
2A24:  CLRF   FA9
2A26:  BCF    FA6.6
2A28:  BCF    FA6.7
2A2A:  BSF    FA6.0
2A2C:  MOVF   FA8,W
2A2E:  BTFSC  x69.7
2A30:  BSF    FF2.7
2A32:  MOVWF  55
....................     //printf(lcd_putc,"\fdez:%u",dezen_sure); 
....................     //delay_ms(1000); 
....................     if (dezen_sure == 0xFF) dezen_sure = 5; 
2A34:  INCFSZ 55,W
2A36:  BRA    2A3C
2A38:  MOVLW  05
2A3A:  MOVWF  55
....................  
....................     bekle_sure = read_eeprom(EE_ADR_BEKLEME_SURE); 
2A3C:  MOVFF  FF2,169
2A40:  BCF    FF2.7
2A42:  MOVLW  05
2A44:  MOVWF  FA9
2A46:  BCF    FA6.6
2A48:  BCF    FA6.7
2A4A:  BSF    FA6.0
2A4C:  MOVF   FA8,W
2A4E:  BTFSC  x69.7
2A50:  BSF    FF2.7
2A52:  MOVWF  57
....................     if (bekle_sure == 0xFF) bekle_sure = 5; 
2A54:  INCFSZ 57,W
2A56:  BRA    2A5C
2A58:  MOVLW  05
2A5A:  MOVWF  57
....................      
....................     valf_sure=read_eeprom(EE_ADR_VALF_SURE); 
2A5C:  MOVFF  FF2,169
2A60:  BCF    FF2.7
2A62:  MOVLW  06
2A64:  MOVWF  FA9
2A66:  BCF    FA6.6
2A68:  BCF    FA6.7
2A6A:  BSF    FA6.0
2A6C:  MOVF   FA8,W
2A6E:  BTFSC  x69.7
2A70:  BSF    FF2.7
2A72:  MOVWF  56
....................     if(valf_sure==0xFF) valf_sure=1;   //10*100=1000 mS 
2A74:  INCFSZ 56,W
2A76:  BRA    2A7C
2A78:  MOVLW  01
2A7A:  MOVWF  56
....................     bip_basla(); 
2A7C:  MOVLW  32
2A7E:  MOVWF  x93
2A80:  MOVLW  02
2A82:  MOVWF  x94
2A84:  MOVLW  7C
2A86:  MOVWF  x96
2A88:  MOVLW  15
2A8A:  MOVWF  x95
2A8C:  MOVLB  0
2A8E:  CALL   08FE
....................  
....................     dil_sec = read_eeprom(EE_ADR_DIL_SEC); 
2A92:  MOVFF  FF2,169
2A96:  BCF    FF2.7
2A98:  MOVLW  10
2A9A:  MOVWF  FA9
2A9C:  BCF    FA6.6
2A9E:  BCF    FA6.7
2AA0:  BSF    FA6.0
2AA2:  MOVF   FA8,W
2AA4:  MOVLB  1
2AA6:  BTFSC  x69.7
2AA8:  BSF    FF2.7
2AAA:  MOVLB  0
2AAC:  MOVWF  x60
....................  
....................     // printf(lcd_putc,"\fdil:%u",dil_sec); 
....................  
....................     if (dil_sec == 0xFF || dil_sec == 0) 
2AAE:  INCFSZ x60,W
2AB0:  BRA    2AB4
2AB2:  BRA    2AB8
2AB4:  MOVF   x60,F
2AB6:  BNZ   2ABC
....................         dil_sec = DIL_TR; 
2AB8:  MOVLW  14
2ABA:  MOVWF  x60
....................  
....................     lcd_msg_baslik = dilTxtGetir(dil_sec, 1); 
2ABC:  MOVFF  60,193
2AC0:  MOVLW  01
2AC2:  MOVLB  1
2AC4:  MOVWF  x94
2AC6:  MOVLB  0
2AC8:  CALL   0BF4
2ACC:  MOVFF  02,62
2AD0:  MOVFF  01,61
....................     lcd_msg_depo = dilTxtGetir(dil_sec, 2); 
2AD4:  MOVFF  60,193
2AD8:  MOVLW  02
2ADA:  MOVLB  1
2ADC:  MOVWF  x94
2ADE:  MOVLB  0
2AE0:  CALL   0BF4
2AE4:  MOVFF  02,64
2AE8:  MOVFF  01,63
....................     lcd_msg_sure = dilTxtGetir(dil_sec, 3); 
2AEC:  MOVFF  60,193
2AF0:  MOVLW  03
2AF2:  MOVLB  1
2AF4:  MOVWF  x94
2AF6:  MOVLB  0
2AF8:  CALL   0BF4
2AFC:  MOVFF  02,68
2B00:  MOVFF  01,67
....................  
....................     kul_say = kul_say_ee_islem(KUL_SAY_EE_OKU, kul_say); //1999999LL; 
2B04:  MOVLW  4F
2B06:  MOVLB  1
2B08:  MOVWF  x69
2B0A:  MOVFF  54,16D
2B0E:  MOVFF  53,16C
2B12:  MOVFF  52,16B
2B16:  MOVFF  51,16A
2B1A:  MOVLB  0
2B1C:  CALL   0D48
2B20:  CLRF   54
2B22:  CLRF   53
2B24:  MOVFF  02,52
2B28:  MOVFF  01,51
....................     lcd_msg_sayac = dilTxtGetir(dil_sec, 11); 
2B2C:  MOVFF  60,193
2B30:  MOVLW  0B
2B32:  MOVLB  1
2B34:  MOVWF  x94
2B36:  MOVLB  0
2B38:  CALL   0BF4
2B3C:  MOVFF  02,6A
2B40:  MOVFF  01,69
....................  
....................     printf(lcd_putc, "\f%s", lcd_msg_baslik); 
2B44:  MOVLW  0C
2B46:  MOVLB  1
2B48:  MOVWF  x96
2B4A:  MOVLB  0
2B4C:  CALL   0842
2B50:  MOVFF  62,FEA
2B54:  MOVFF  61,FE9
2B58:  CALL   0EA0
....................     printf(lcd_putc, "\n%s:%Lu", lcd_msg_sayac, kul_say); 
2B5C:  MOVLW  0A
2B5E:  MOVLB  1
2B60:  MOVWF  x96
2B62:  MOVLB  0
2B64:  CALL   0842
2B68:  MOVFF  6A,FEA
2B6C:  MOVFF  69,FE9
2B70:  CALL   0EA0
2B74:  MOVLW  3A
2B76:  MOVLB  1
2B78:  MOVWF  x96
2B7A:  MOVLB  0
2B7C:  CALL   0842
2B80:  MOVLW  41
2B82:  MOVWF  FE9
2B84:  MOVFF  54,170
2B88:  MOVFF  53,16F
2B8C:  MOVFF  52,16E
2B90:  MOVFF  51,16D
2B94:  CALL   0F58
....................     delay_ms(1500); 
2B98:  MOVLW  06
2B9A:  MOVLB  1
2B9C:  MOVWF  x69
2B9E:  MOVLW  FA
2BA0:  MOVWF  x99
2BA2:  MOVLB  0
2BA4:  CALL   06CE
2BA8:  MOVLB  1
2BAA:  DECFSZ x69,F
2BAC:  BRA    2B9E
....................  
....................     printf(lcd_putc, "\f%s", lcd_msg_baslik); 
2BAE:  MOVLW  0C
2BB0:  MOVWF  x96
2BB2:  MOVLB  0
2BB4:  CALL   0842
2BB8:  MOVFF  62,FEA
2BBC:  MOVFF  61,FE9
2BC0:  CALL   0EA0
....................     printf(lcd_putc, "\n%s: ???", lcd_msg_depo); 
2BC4:  MOVLW  0A
2BC6:  MOVLB  1
2BC8:  MOVWF  x96
2BCA:  MOVLB  0
2BCC:  CALL   0842
2BD0:  MOVFF  64,FEA
2BD4:  MOVFF  63,FE9
2BD8:  CALL   0EA0
2BDC:  MOVLW  87
2BDE:  MOVWF  FF6
2BE0:  MOVLW  06
2BE2:  MOVWF  FF7
2BE4:  MOVLW  05
2BE6:  MOVLB  1
2BE8:  MOVWF  x93
2BEA:  MOVLB  0
2BEC:  CALL   1016
....................  
....................     //delay_ms(1500); 
....................  
....................     time_lcd = millis(); 
2BF0:  MOVFF  31,50
2BF4:  MOVFF  30,4F
2BF8:  MOVFF  2F,4E
2BFC:  MOVFF  2E,4D
....................  
.................... #ifdef PIR_SENS_TEKLI 
....................     while ((millis() - time_lcd) < 30000LL) { 
2C00:  MOVF   4D,W
2C02:  SUBWF  2E,W
2C04:  MOVLB  1
2C06:  MOVWF  x69
2C08:  MOVF   4E,W
2C0A:  SUBWFB 2F,W
2C0C:  MOVWF  x6A
2C0E:  MOVF   4F,W
2C10:  SUBWFB 30,W
2C12:  MOVWF  x6B
2C14:  MOVF   50,W
2C16:  SUBWFB 31,W
2C18:  MOVWF  x6C
2C1A:  MOVF   x6C,F
2C1C:  BNZ   2C8E
2C1E:  MOVF   x6B,F
2C20:  BNZ   2C8E
2C22:  MOVF   x6A,W
2C24:  SUBLW  75
2C26:  BNC   2C8E
2C28:  BNZ   2C30
2C2A:  MOVF   x69,W
2C2C:  SUBLW  2F
2C2E:  BNC   2C8E
....................         printf(lcd_putc, "\f%s", lcd_msg_baslik); 
2C30:  MOVLW  0C
2C32:  MOVWF  x96
2C34:  MOVLB  0
2C36:  CALL   0842
2C3A:  MOVFF  62,FEA
2C3E:  MOVFF  61,FE9
2C42:  CALL   0EA0
....................         printf(lcd_putc, "\nSENS:%lu", millis()); 
2C46:  MOVLW  8E
2C48:  MOVWF  FF6
2C4A:  MOVLW  06
2C4C:  MOVWF  FF7
2C4E:  MOVLW  06
2C50:  MOVLB  1
2C52:  MOVWF  x93
2C54:  MOVLB  0
2C56:  CALL   1016
2C5A:  MOVLW  41
2C5C:  MOVWF  FE9
2C5E:  MOVFF  31,170
2C62:  MOVFF  30,16F
2C66:  MOVFF  2F,16E
2C6A:  MOVFF  2E,16D
2C6E:  CALL   0F58
....................         delay_ms(250); 
2C72:  MOVLW  FA
2C74:  MOVLB  1
2C76:  MOVWF  x99
2C78:  MOVLB  0
2C7A:  CALL   06CE
....................         if (input(GIR_SENS1_PIN)) break; 
2C7E:  BSF    F93.0
2C80:  BTFSS  F81.0
2C82:  BRA    2C8A
2C84:  MOVLB  1
2C86:  BRA    2C8E
2C88:  MOVLB  0
2C8A:  BRA    2C00
2C8C:  MOVLB  1
....................     } 
.................... #endif 
....................      
....................     output_high(VALF_ROLE_PIN); 
2C8E:  BCF    F94.1
2C90:  BSF    F8B.1
....................     time_lcd = millis(); 
2C92:  MOVFF  31,50
2C96:  MOVFF  30,4F
2C9A:  MOVFF  2F,4E
2C9E:  MOVFF  2E,4D
....................      
....................     /*      ANA DÖngü   */ 
....................      
....................     while (1) { 
....................  
.................... #ifdef BARIYER_SENS 
....................  
....................         if (!input(GIR_SENS1_PIN) && giris_yon == GIRIS_YOK && depo_durum != DEPO_BOS) { 
....................             delay_ms(1000); 
....................             bip_giris(); 
....................  
....................             output_high(MOTOR_PIN); 
....................             giris_yon = GIR1_GIR2; 
....................  
....................             output_high(DUR_LED_PIN); 
....................             output_high(DUR2_LED_PIN); 
....................             output_low(GEC_LED_PIN); 
....................             output_low(GEC2_LED_PIN); 
....................  
....................             time_dezen_sure = millis(); 
....................         } 
....................  
....................         if (!input(GIR_SENS2_PIN) && giris_yon == GIRIS_YOK && depo_durum != DEPO_BOS) { 
....................             delay_ms(1000); 
....................             bip_giris(); 
....................             output_high(MOTOR_PIN); 
....................             giris_yon = GIR2_GIR1; 
....................  
....................             output_high(DUR_LED_PIN); 
....................             output_high(DUR2_LED_PIN); 
....................             output_low(GEC_LED_PIN); 
....................             output_low(GEC2_LED_PIN); 
....................  
....................             time_dezen_sure = millis(); 
....................         } 
....................  
....................         if (giris_yon == GIR1_GIR2) { 
....................  
....................             if (!input(GIR_SENS2_PIN)) { 
....................                 delay_ms(500); 
....................                 output_low(MOTOR_PIN); 
....................                 giris_yon = GIRIS_YOK; 
....................  
....................                 output_high((GEC_LED_PIN)); 
....................                 output_high((GEC2_LED_PIN)); 
....................                 output_low(DUR_LED_PIN); 
....................                 output_low(DUR2_LED_PIN); 
....................  
....................                 time_dezen_sure = millis(); 
....................             } 
....................         } 
....................  
....................         if (giris_yon == GIR2_GIR1) { 
....................  
....................             if (!input(GIR_SENS1_PIN)) { 
....................                 delay_ms(500); 
....................                 output_low(MOTOR_PIN); 
....................                 giris_yon = GIRIS_YOK; 
....................  
....................                 output_high((GEC_LED_PIN)); 
....................                 output_high((GEC2_LED_PIN)); 
....................                 output_low(DUR_LED_PIN); 
....................                 output_low(DUR2_LED_PIN); 
....................                 time_dezen_sure = millis(); 
....................             } 
....................         } 
....................  
....................         if (giris_yon != GIRIS_YOK) { 
....................             printf(lcd_putc, "\fOTO DEZENFEKTE"); 
....................             printf(lcd_putc, "\nSURE:%Lu", (millis() - time_dezen_sure)); 
....................  
....................             if ((millis() - time_dezen_sure)>((unsigned long) (dezen_sure * 1000))) { 
....................                 output_low(MOTOR_PIN); 
....................                 giris_yon = GIRIS_YOK; 
....................  
....................                 output_high((GEC_LED_PIN)); 
....................                 output_high((GEC2_LED_PIN)); 
....................                 output_low(DUR_LED_PIN); 
....................                 output_low(DUR2_LED_PIN); 
....................  
....................                 setMillis(0); 
....................                 time_dezen_sure = millis(); 
....................             } 
....................  
....................         } else { 
....................  
....................             if (millis() - time_lcd > 1000) { 
....................                 printf(lcd_putc, "\fOTO DEZENFEKTE"); 
....................  
....................                 if (depo_durum == DEPO_BOS) { 
....................                     printf(lcd_putc, "\nDepo : BOS"); 
....................                     output_low(MOTOR_PIN); 
....................                     giris_yon = GIRIS_YOK; 
....................                     bip_hata(); 
....................                     delay_ms(1000); 
....................                 } 
....................                 if (depo_durum == DEPO_MIN) { 
....................                     printf(lcd_putc, "\nDepo:MIN-25"); 
....................                 } 
....................                 if (depo_durum == DEPO_ORTA) { 
....................                     printf(lcd_putc, "\nDepo:ORTA-50"); 
....................  
....................                 } 
....................                 if (depo_durum == DEPO_MAX) { 
....................                     printf(lcd_putc, "\nDepo:MAX-100"); 
....................  
....................                 } 
....................  
....................                 time_lcd = millis(); 
....................             } 
....................  
....................         } 
....................  
....................         if (depo_durum == DEPO_BOS) { 
....................             output_low(MOTOR_PIN); 
....................             giris_yon = GIRIS_YOK; 
....................         } 
....................  
.................... #endif 
....................  
.................... #ifdef PIR_SENS_TEKLI 
....................  
....................         if ((input(GIR_SENS1_PIN) || !input(GIR_SENS2_PIN)) && giris_yon == GIRIS_YOK && depo_durum != DEPO_BOS) { 
2CA2:  BSF    F93.0
2CA4:  BTFSC  F81.0
2CA6:  BRA    2CAE
2CA8:  BSF    F93.1
2CAA:  BTFSC  F81.1
2CAC:  BRA    2CF8
2CAE:  MOVF   58,F
2CB0:  BNZ   2CF8
2CB2:  MOVF   59,W
2CB4:  SUBLW  0A
2CB6:  BZ    2CF8
....................             delay_ms(100); 
2CB8:  MOVLW  64
2CBA:  MOVWF  x99
2CBC:  MOVLB  0
2CBE:  CALL   06CE
....................             bip_giris(); 
2CC2:  MOVLW  64
2CC4:  MOVLB  1
2CC6:  MOVWF  x93
2CC8:  MOVLW  05
2CCA:  MOVWF  x94
2CCC:  MOVLW  7C
2CCE:  MOVWF  x96
2CD0:  MOVLW  15
2CD2:  MOVWF  x95
2CD4:  MOVLB  0
2CD6:  CALL   08FE
....................             output_high(MOTOR_PIN); 
2CDA:  BCF    F94.2
2CDC:  BSF    F8B.2
....................             valfOff() 
2CDE:  BCF    F94.1
2CE0:  BCF    F8B.1
....................             giris_yon = GIR1_GIR2; 
2CE2:  MOVLW  01
2CE4:  MOVWF  58
....................             time_dezen_sure = millis(); 
2CE6:  MOVFF  31,44
2CEA:  MOVFF  30,43
2CEE:  MOVFF  2F,42
2CF2:  MOVFF  2E,41
2CF6:  MOVLB  1
....................              
....................         } 
....................          
....................         if(millis()-time_valf_sure>(unsigned long long)(valf_sure*100LL)){ 
2CF8:  MOVF   45,W
2CFA:  SUBWF  2E,W
2CFC:  MOVWF  x69
2CFE:  MOVF   46,W
2D00:  SUBWFB 2F,W
2D02:  MOVWF  x6A
2D04:  MOVF   47,W
2D06:  SUBWFB 30,W
2D08:  MOVWF  x6B
2D0A:  MOVF   48,W
2D0C:  SUBWFB 31,W
2D0E:  MOVWF  x6C
2D10:  CLRF   x70
2D12:  CLRF   x6F
2D14:  CLRF   x6E
2D16:  MOVFF  56,16D
2D1A:  CLRF   x74
2D1C:  CLRF   x73
2D1E:  CLRF   x72
2D20:  MOVLW  64
2D22:  MOVWF  x71
2D24:  MOVLB  0
2D26:  CALL   103E
2D2A:  MOVF   03,W
2D2C:  MOVLB  1
2D2E:  SUBWF  x6C,W
2D30:  BNC   2D4E
2D32:  BNZ   2D4A
2D34:  MOVF   02,W
2D36:  SUBWF  x6B,W
2D38:  BNC   2D4E
2D3A:  BNZ   2D4A
2D3C:  MOVF   01,W
2D3E:  SUBWF  x6A,W
2D40:  BNC   2D4E
2D42:  BNZ   2D4A
2D44:  MOVF   x69,W
2D46:  SUBWF  00,W
2D48:  BC    2D4E
....................             valfOff(); // basýnç boþaltma süesi bitti basýncý tut. 
2D4A:  BCF    F94.1
2D4C:  BCF    F8B.1
....................         } 
....................  
....................         if (giris_yon != GIRIS_YOK) { 
2D4E:  MOVF   58,F
2D50:  BTFSC  FD8.2
2D52:  BRA    2F44
....................             lcd_msg_baslik = dilTxtGetir(dil_sec, 1); 
2D54:  MOVFF  60,193
2D58:  MOVLW  01
2D5A:  MOVWF  x94
2D5C:  MOVLB  0
2D5E:  CALL   0BF4
2D62:  MOVFF  02,62
2D66:  MOVFF  01,61
....................             lcd_msg_sure = dilTxtGetir(dil_sec, 3); 
2D6A:  MOVFF  60,193
2D6E:  MOVLW  03
2D70:  MOVLB  1
2D72:  MOVWF  x94
2D74:  MOVLB  0
2D76:  CALL   0BF4
2D7A:  MOVFF  02,68
2D7E:  MOVFF  01,67
....................             printf(lcd_putc, "\f%s", lcd_msg_baslik); 
2D82:  MOVLW  0C
2D84:  MOVLB  1
2D86:  MOVWF  x96
2D88:  MOVLB  0
2D8A:  CALL   0842
2D8E:  MOVFF  62,FEA
2D92:  MOVFF  61,FE9
2D96:  CALL   0EA0
....................             printf(lcd_putc, "\n%s:%Lu", lcd_msg_sure, (millis() - time_dezen_sure)); 
2D9A:  MOVF   41,W
2D9C:  SUBWF  2E,W
2D9E:  MOVLB  1
2DA0:  MOVWF  x69
2DA2:  MOVF   42,W
2DA4:  SUBWFB 2F,W
2DA6:  MOVWF  x6A
2DA8:  MOVF   43,W
2DAA:  SUBWFB 30,W
2DAC:  MOVWF  x6B
2DAE:  MOVF   44,W
2DB0:  SUBWFB 31,W
2DB2:  MOVWF  x6C
2DB4:  MOVLW  0A
2DB6:  MOVWF  x96
2DB8:  MOVLB  0
2DBA:  CALL   0842
2DBE:  MOVFF  68,FEA
2DC2:  MOVFF  67,FE9
2DC6:  CALL   0EA0
2DCA:  MOVLW  3A
2DCC:  MOVLB  1
2DCE:  MOVWF  x96
2DD0:  MOVLB  0
2DD2:  CALL   0842
2DD6:  MOVLW  41
2DD8:  MOVWF  FE9
2DDA:  MOVFF  16C,170
2DDE:  MOVFF  16B,16F
2DE2:  MOVFF  16A,16E
2DE6:  MOVFF  169,16D
2DEA:  CALL   0F58
....................  
....................             if (((millis() - time_dezen_sure)>((unsigned long long) (dezen_sure * 1000))) && giris_yon == GIR1_GIR2) { 
2DEE:  MOVF   41,W
2DF0:  SUBWF  2E,W
2DF2:  MOVLB  1
2DF4:  MOVWF  x69
2DF6:  MOVF   42,W
2DF8:  SUBWFB 2F,W
2DFA:  MOVWF  x6A
2DFC:  MOVF   43,W
2DFE:  SUBWFB 30,W
2E00:  MOVWF  x6B
2E02:  MOVF   44,W
2E04:  SUBWFB 31,W
2E06:  MOVWF  x6C
2E08:  CLRF   x70
2E0A:  MOVFF  55,16F
2E0E:  MOVLW  03
2E10:  MOVWF  x72
2E12:  MOVLW  E8
2E14:  MOVWF  x71
2E16:  MOVLB  0
2E18:  CALL   1098
2E1C:  MOVFF  02,03
2E20:  MOVFF  01,00
2E24:  MOVFF  02,01
2E28:  CLRF   02
2E2A:  CLRF   03
2E2C:  MOVF   03,W
2E2E:  MOVLB  1
2E30:  SUBWF  x6C,W
2E32:  BNC   2ECE
2E34:  BNZ   2E4C
2E36:  MOVF   02,W
2E38:  SUBWF  x6B,W
2E3A:  BNC   2ECE
2E3C:  BNZ   2E4C
2E3E:  MOVF   01,W
2E40:  SUBWF  x6A,W
2E42:  BNC   2ECE
2E44:  BNZ   2E4C
2E46:  MOVF   x69,W
2E48:  SUBWF  00,W
2E4A:  BC    2ECE
2E4C:  DECFSZ 58,W
2E4E:  BRA    2ECE
....................                 output_low(MOTOR_PIN); 
2E50:  BCF    F94.2
2E52:  BCF    F8B.2
....................                 valfOn();   //dezenfekte bitti basýncý boþalt 
2E54:  BCF    F94.1
2E56:  BSF    F8B.1
....................                 kul_say++; 
2E58:  MOVLW  01
2E5A:  ADDWF  51,F
2E5C:  BTFSC  FD8.0
2E5E:  INCF   52,F
2E60:  BTFSC  FD8.2
2E62:  INCF   53,F
2E64:  BTFSC  FD8.2
2E66:  INCF   54,F
....................                 kul_say_ee_islem(KUL_SAY_EE_KAYDET, kul_say); 
2E68:  MOVLW  4B
2E6A:  MOVWF  x69
2E6C:  MOVFF  54,16D
2E70:  MOVFF  53,16C
2E74:  MOVFF  52,16B
2E78:  MOVFF  51,16A
2E7C:  MOVLB  0
2E7E:  CALL   0D48
....................  
....................                 bip_bekle(); 
2E82:  MOVLW  0A
2E84:  MOVLB  1
2E86:  MOVWF  x93
2E88:  MOVWF  x94
2E8A:  MOVLW  7C
2E8C:  MOVWF  x96
2E8E:  MOVLW  15
2E90:  MOVWF  x95
2E92:  MOVLB  0
2E94:  CALL   08FE
....................                 time_bekle_sure = millis(); 
2E98:  MOVFF  31,4C
2E9C:  MOVFF  30,4B
2EA0:  MOVFF  2F,4A
2EA4:  MOVFF  2E,49
....................                 time_dezen_sure = millis(); 
2EA8:  MOVFF  31,44
2EAC:  MOVFF  30,43
2EB0:  MOVFF  2F,42
2EB4:  MOVFF  2E,41
....................                 giris_yon = GIR2_GIR1; 
2EB8:  MOVLW  02
2EBA:  MOVWF  58
....................                 time_valf_sure = millis(); 
2EBC:  MOVFF  31,48
2EC0:  MOVFF  30,47
2EC4:  MOVFF  2F,46
2EC8:  MOVFF  2E,45
2ECC:  MOVLB  1
....................             } 
....................  
....................             if ((millis() - time_bekle_sure > ((unsigned long long) (bekle_sure * 1000LL))) && giris_yon == GIR2_GIR1) { 
2ECE:  MOVF   49,W
2ED0:  SUBWF  2E,W
2ED2:  MOVWF  x69
2ED4:  MOVF   4A,W
2ED6:  SUBWFB 2F,W
2ED8:  MOVWF  x6A
2EDA:  MOVF   4B,W
2EDC:  SUBWFB 30,W
2EDE:  MOVWF  x6B
2EE0:  MOVF   4C,W
2EE2:  SUBWFB 31,W
2EE4:  MOVWF  x6C
2EE6:  CLRF   x70
2EE8:  CLRF   x6F
2EEA:  CLRF   x6E
2EEC:  MOVFF  57,16D
2EF0:  CLRF   x74
2EF2:  CLRF   x73
2EF4:  MOVLW  03
2EF6:  MOVWF  x72
2EF8:  MOVLW  E8
2EFA:  MOVWF  x71
2EFC:  MOVLB  0
2EFE:  CALL   103E
2F02:  MOVF   03,W
2F04:  MOVLB  1
2F06:  SUBWF  x6C,W
2F08:  BNC   2F42
2F0A:  BNZ   2F22
2F0C:  MOVF   02,W
2F0E:  SUBWF  x6B,W
2F10:  BNC   2F42
2F12:  BNZ   2F22
2F14:  MOVF   01,W
2F16:  SUBWF  x6A,W
2F18:  BNC   2F42
2F1A:  BNZ   2F22
2F1C:  MOVF   x69,W
2F1E:  SUBWF  00,W
2F20:  BC    2F42
2F22:  MOVF   58,W
2F24:  SUBLW  02
2F26:  BNZ   2F42
....................                 setMillis(0); 
2F28:  CLRF   31
2F2A:  CLRF   30
2F2C:  CLRF   2F
2F2E:  CLRF   2E
....................                 giris_yon = GIRIS_YOK; 
2F30:  CLRF   58
....................                 time_dezen_sure = millis(); 
2F32:  MOVFF  31,44
2F36:  MOVFF  30,43
2F3A:  MOVFF  2F,42
2F3E:  MOVFF  2E,41
....................             } 
....................  
....................         } else { 
2F42:  BRA    3214
....................  
....................             if (millis() - time_lcd > 1000) { 
2F44:  MOVF   4D,W
2F46:  SUBWF  2E,W
2F48:  MOVWF  x69
2F4A:  MOVF   4E,W
2F4C:  SUBWFB 2F,W
2F4E:  MOVWF  x6A
2F50:  MOVF   4F,W
2F52:  SUBWFB 30,W
2F54:  MOVWF  x6B
2F56:  MOVF   50,W
2F58:  SUBWFB 31,W
2F5A:  MOVWF  x6C
2F5C:  MOVF   x6C,F
2F5E:  BNZ   2F78
2F60:  MOVF   x6B,F
2F62:  BNZ   2F78
2F64:  MOVF   x6A,W
2F66:  SUBLW  02
2F68:  BTFSC  FD8.0
2F6A:  BRA    3168
2F6C:  XORLW  FF
2F6E:  BNZ   2F78
2F70:  MOVF   x69,W
2F72:  SUBLW  E8
2F74:  BTFSC  FD8.0
2F76:  BRA    3168
....................  
....................                 lcd_msg_baslik = dilTxtGetir(dil_sec, 1); 
2F78:  MOVFF  60,193
2F7C:  MOVLW  01
2F7E:  MOVWF  x94
2F80:  MOVLB  0
2F82:  CALL   0BF4
2F86:  MOVFF  02,62
2F8A:  MOVFF  01,61
....................                 printf(lcd_putc, "\f%s", lcd_msg_baslik); 
2F8E:  MOVLW  0C
2F90:  MOVLB  1
2F92:  MOVWF  x96
2F94:  MOVLB  0
2F96:  CALL   0842
2F9A:  MOVFF  62,FEA
2F9E:  MOVFF  61,FE9
2FA2:  CALL   0EA0
....................  
....................                 if (depo_durum == DEPO_BOS) { 
2FA6:  MOVF   59,W
2FA8:  SUBLW  0A
2FAA:  BNZ   3046
....................                     lcd_msg_depo = dilTxtGetir(dil_sec, 2); 
2FAC:  MOVFF  60,193
2FB0:  MOVLW  02
2FB2:  MOVLB  1
2FB4:  MOVWF  x94
2FB6:  MOVLB  0
2FB8:  CALL   0BF4
2FBC:  MOVFF  02,64
2FC0:  MOVFF  01,63
....................                     lcd_msg_depo_drm = dilTxtGetir(dil_sec, 10); 
2FC4:  MOVFF  60,193
2FC8:  MOVLW  0A
2FCA:  MOVLB  1
2FCC:  MOVWF  x94
2FCE:  MOVLB  0
2FD0:  CALL   0BF4
2FD4:  MOVFF  02,66
2FD8:  MOVFF  01,65
....................                     printf(lcd_putc, "\n%s:%s", lcd_msg_depo, lcd_msg_depo_drm); 
2FDC:  MOVLW  0A
2FDE:  MOVLB  1
2FE0:  MOVWF  x96
2FE2:  MOVLB  0
2FE4:  CALL   0842
2FE8:  MOVFF  64,FEA
2FEC:  MOVFF  63,FE9
2FF0:  CALL   0EA0
2FF4:  MOVLW  3A
2FF6:  MOVLB  1
2FF8:  MOVWF  x96
2FFA:  MOVLB  0
2FFC:  CALL   0842
3000:  MOVFF  66,FEA
3004:  MOVFF  65,FE9
3008:  CALL   0EA0
....................                     output_low(MOTOR_PIN); 
300C:  BCF    F94.2
300E:  BCF    F8B.2
....................                     output_high(ROLE_PIN); // dalgýç pompaya gerilim ver. 
3010:  BCF    F94.0
3012:  BSF    F8B.0
....................                     giris_yon = GIRIS_YOK; 
3014:  CLRF   58
....................                      
....................                     bip_hata(); 
3016:  MOVLW  FA
3018:  MOVLB  1
301A:  MOVWF  x93
301C:  MOVLW  05
301E:  MOVWF  x94
3020:  MOVLW  7C
3022:  MOVWF  x96
3024:  MOVLW  15
3026:  MOVWF  x95
3028:  MOVLB  0
302A:  CALL   08FE
....................                     delay_ms(1000); 
302E:  MOVLW  04
3030:  MOVLB  1
3032:  MOVWF  x69
3034:  MOVLW  FA
3036:  MOVWF  x99
3038:  MOVLB  0
303A:  CALL   06CE
303E:  MOVLB  1
3040:  DECFSZ x69,F
3042:  BRA    3034
3044:  MOVLB  0
....................                 } 
....................                 if (depo_durum == DEPO_MIN) { 
3046:  MOVF   59,W
3048:  SUBLW  0B
304A:  BNZ   3094
....................                     lcd_msg_depo = dilTxtGetir(dil_sec, 2); 
304C:  MOVFF  60,193
3050:  MOVLW  02
3052:  MOVLB  1
3054:  MOVWF  x94
3056:  MOVLB  0
3058:  CALL   0BF4
305C:  MOVFF  02,64
3060:  MOVFF  01,63
....................                     printf(lcd_putc, "\n%s:MIN-25", lcd_msg_depo); 
3064:  MOVLW  0A
3066:  MOVLB  1
3068:  MOVWF  x96
306A:  MOVLB  0
306C:  CALL   0842
3070:  MOVFF  64,FEA
3074:  MOVFF  63,FE9
3078:  CALL   0EA0
307C:  MOVLW  9B
307E:  MOVWF  FF6
3080:  MOVLW  06
3082:  MOVWF  FF7
3084:  MOVLW  07
3086:  MOVLB  1
3088:  MOVWF  x93
308A:  MOVLB  0
308C:  CALL   1016
....................                     output_high(ROLE_PIN); // dalgýç pompaya gerilim ver. 
3090:  BCF    F94.0
3092:  BSF    F8B.0
....................                 } 
....................                 if (depo_durum == DEPO_ORTA) { 
3094:  MOVF   59,W
3096:  SUBLW  0C
3098:  BNZ   3112
....................                     lcd_msg_depo = dilTxtGetir(dil_sec, 2); 
309A:  MOVFF  60,193
309E:  MOVLW  02
30A0:  MOVLB  1
30A2:  MOVWF  x94
30A4:  MOVLB  0
30A6:  CALL   0BF4
30AA:  MOVFF  02,64
30AE:  MOVFF  01,63
....................                     lcd_msg_depo_drm = dilTxtGetir(dil_sec, 4); 
30B2:  MOVFF  60,193
30B6:  MOVLW  04
30B8:  MOVLB  1
30BA:  MOVWF  x94
30BC:  MOVLB  0
30BE:  CALL   0BF4
30C2:  MOVFF  02,66
30C6:  MOVFF  01,65
....................                     printf(lcd_putc, "\n%s:%s-50", lcd_msg_depo, lcd_msg_depo_drm); 
30CA:  MOVLW  0A
30CC:  MOVLB  1
30CE:  MOVWF  x96
30D0:  MOVLB  0
30D2:  CALL   0842
30D6:  MOVFF  64,FEA
30DA:  MOVFF  63,FE9
30DE:  CALL   0EA0
30E2:  MOVLW  3A
30E4:  MOVLB  1
30E6:  MOVWF  x96
30E8:  MOVLB  0
30EA:  CALL   0842
30EE:  MOVFF  66,FEA
30F2:  MOVFF  65,FE9
30F6:  CALL   0EA0
30FA:  MOVLW  AA
30FC:  MOVWF  FF6
30FE:  MOVLW  06
3100:  MOVWF  FF7
3102:  MOVLW  03
3104:  MOVLB  1
3106:  MOVWF  x93
3108:  MOVLB  0
310A:  CALL   1016
....................                     output_high(ROLE_PIN); // dalgýç pompaya gerilim ver. 
310E:  BCF    F94.0
3110:  BSF    F8B.0
....................  
....................                 } 
....................                 if (depo_durum == DEPO_MAX) { 
3112:  MOVF   59,W
3114:  SUBLW  0D
3116:  BNZ   3162
....................                     lcd_msg_depo = dilTxtGetir(dil_sec, 2); 
3118:  MOVFF  60,193
311C:  MOVLW  02
311E:  MOVLB  1
3120:  MOVWF  x94
3122:  MOVLB  0
3124:  CALL   0BF4
3128:  MOVFF  02,64
312C:  MOVFF  01,63
....................                     printf(lcd_putc, "\n%s:MAX-100", lcd_msg_depo); 
3130:  MOVLW  0A
3132:  MOVLB  1
3134:  MOVWF  x96
3136:  MOVLB  0
3138:  CALL   0842
313C:  MOVFF  64,FEA
3140:  MOVFF  63,FE9
3144:  CALL   0EA0
3148:  MOVLW  B1
314A:  MOVWF  FF6
314C:  MOVLW  06
314E:  MOVWF  FF7
3150:  MOVLW  08
3152:  MOVLB  1
3154:  MOVWF  x93
3156:  MOVLB  0
3158:  CALL   1016
....................                     output_low(ROLE_PIN); // dalgýç pompaya gerilim ver. 
315C:  BCF    F94.0
315E:  BCF    F8B.0
....................  
....................                 }else{ 
3160:  BRA    3166
....................                      output_high(ROLE_PIN); // dalgýç pompaya gerilim ver. 
3162:  BCF    F94.0
3164:  BSF    F8B.0
3166:  MOVLB  1
....................                 } 
....................             } 
....................  
....................             if (millis() - time_lcd > 2000) { 
3168:  MOVF   4D,W
316A:  SUBWF  2E,W
316C:  MOVWF  x69
316E:  MOVF   4E,W
3170:  SUBWFB 2F,W
3172:  MOVWF  x6A
3174:  MOVF   4F,W
3176:  SUBWFB 30,W
3178:  MOVWF  x6B
317A:  MOVF   50,W
317C:  SUBWFB 31,W
317E:  MOVWF  x6C
3180:  MOVF   x6C,F
3182:  BNZ   3198
3184:  MOVF   x6B,F
3186:  BNZ   3198
3188:  MOVF   x6A,W
318A:  SUBLW  06
318C:  BC    3214
318E:  XORLW  FF
3190:  BNZ   3198
3192:  MOVF   x69,W
3194:  SUBLW  D0
3196:  BC    3214
....................  
....................                 lcd_msg_sayac = dilTxtGetir(dil_sec, 11); 
3198:  MOVFF  60,193
319C:  MOVLW  0B
319E:  MOVWF  x94
31A0:  MOVLB  0
31A2:  CALL   0BF4
31A6:  MOVFF  02,6A
31AA:  MOVFF  01,69
....................                 printf(lcd_putc, "\f%s", lcd_msg_baslik); 
31AE:  MOVLW  0C
31B0:  MOVLB  1
31B2:  MOVWF  x96
31B4:  MOVLB  0
31B6:  CALL   0842
31BA:  MOVFF  62,FEA
31BE:  MOVFF  61,FE9
31C2:  CALL   0EA0
....................                 printf(lcd_putc, "\n%s:%Lu", lcd_msg_sayac, kul_say); 
31C6:  MOVLW  0A
31C8:  MOVLB  1
31CA:  MOVWF  x96
31CC:  MOVLB  0
31CE:  CALL   0842
31D2:  MOVFF  6A,FEA
31D6:  MOVFF  69,FE9
31DA:  CALL   0EA0
31DE:  MOVLW  3A
31E0:  MOVLB  1
31E2:  MOVWF  x96
31E4:  MOVLB  0
31E6:  CALL   0842
31EA:  MOVLW  41
31EC:  MOVWF  FE9
31EE:  MOVFF  54,170
31F2:  MOVFF  53,16F
31F6:  MOVFF  52,16E
31FA:  MOVFF  51,16D
31FE:  CALL   0F58
....................  
....................                 time_lcd = millis(); 
3202:  MOVFF  31,50
3206:  MOVFF  30,4F
320A:  MOVFF  2F,4E
320E:  MOVFF  2E,4D
3212:  MOVLB  1
....................             } 
....................  
....................         } 
.................... #endif 
....................  
....................         sens_adc_oku(); 
3214:  MOVLB  0
3216:  CALL   10BA
....................  
....................         //if(input(SEVIYE_SENS1_PIN)) 
....................         if (an_sv1 > 800) //4 V gibi 
321A:  MOVF   5B,W
321C:  SUBLW  02
321E:  BC    3232
3220:  XORLW  FF
3222:  BNZ   322A
3224:  MOVF   5A,W
3226:  SUBLW  20
3228:  BC    3232
....................         { 
....................             depo_durum = DEPO_BOS; 
322A:  MOVLW  0A
322C:  MOVWF  59
....................             output_high(ROLE_PIN); // dalgýç pompaya gerilim ver. 
322E:  BCF    F94.0
3230:  BSF    F8B.0
....................         } 
....................         //if(!input(SEVIYE_SENS1_PIN)) 
....................         if (an_sv1 < 700) //3.5 V 
3232:  MOVF   5B,W
3234:  SUBLW  02
3236:  BNC   3248
3238:  BNZ   3240
323A:  MOVF   5A,W
323C:  SUBLW  BB
323E:  BNC   3248
....................         { 
....................             depo_durum = DEPO_MIN; 
3240:  MOVLW  0B
3242:  MOVWF  59
....................             output_high(ROLE_PIN); // dalgýç pompaya gerilim ver. 
3244:  BCF    F94.0
3246:  BSF    F8B.0
....................         } 
....................         //if(!input(SEVIYE_SENS1_PIN) && !input(SEVIYE_SENS2_PIN) ) 
....................         if ((an_sv1 < 700)&& (an_sv2 < 700)) { 
3248:  MOVF   5B,W
324A:  SUBLW  02
324C:  BNC   326C
324E:  BNZ   3256
3250:  MOVF   5A,W
3252:  SUBLW  BB
3254:  BNC   326C
3256:  MOVF   5D,W
3258:  SUBLW  02
325A:  BNC   326C
325C:  BNZ   3264
325E:  MOVF   5C,W
3260:  SUBLW  BB
3262:  BNC   326C
....................             depo_durum = DEPO_ORTA; 
3264:  MOVLW  0C
3266:  MOVWF  59
....................             output_high(ROLE_PIN); // dalgýç pompaya gerilim ver. 
3268:  BCF    F94.0
326A:  BSF    F8B.0
....................         } 
....................         //if(!input(SEVIYE_SENS1_PIN) && !input(SEVIYE_SENS2_PIN) && !input(SEVIYE_SENS3_PIN)) 
....................         if ((an_sv1 < 700)&& (an_sv2 < 700) && (an_sv3 < 700)) { 
326C:  MOVF   5B,W
326E:  SUBLW  02
3270:  BNC   329E
3272:  BNZ   327A
3274:  MOVF   5A,W
3276:  SUBLW  BB
3278:  BNC   329E
327A:  MOVF   5D,W
327C:  SUBLW  02
327E:  BNC   329E
3280:  BNZ   3288
3282:  MOVF   5C,W
3284:  SUBLW  BB
3286:  BNC   329E
3288:  MOVF   5F,W
328A:  SUBLW  02
328C:  BNC   329E
328E:  BNZ   3296
3290:  MOVF   5E,W
3292:  SUBLW  BB
3294:  BNC   329E
....................             depo_durum = DEPO_MAX; 
3296:  MOVLW  0D
3298:  MOVWF  59
....................             output_low(ROLE_PIN); //Dalgýç pompanýn gerilimini kes 
329A:  BCF    F94.0
329C:  BCF    F8B.0
....................         } 
....................  
....................         if (!input(ORTA_BTN_PIN)) { 
329E:  BSF    F92.3
32A0:  BTFSC  F80.3
32A2:  BRA    32D6
....................             delay_ms(250); 
32A4:  MOVLW  FA
32A6:  MOVLB  1
32A8:  MOVWF  x99
32AA:  MOVLB  0
32AC:  CALL   06CE
....................             menu_say++; 
32B0:  INCF   40,F
....................             if (menu_say > 6) { 
32B2:  MOVF   40,W
32B4:  SUBLW  06
32B6:  BC    32D6
....................                 menu_say = 0; 
32B8:  CLRF   40
....................                 bip_basla(); 
32BA:  MOVLW  32
32BC:  MOVLB  1
32BE:  MOVWF  x93
32C0:  MOVLW  02
32C2:  MOVWF  x94
32C4:  MOVLW  7C
32C6:  MOVWF  x96
32C8:  MOVLW  15
32CA:  MOVWF  x95
32CC:  MOVLB  0
32CE:  CALL   08FE
....................                 lcdMenuIslem(); 
32D2:  GOTO   24CE
....................             } 
....................         } 
....................         delay_ms(100); 
32D6:  MOVLW  64
32D8:  MOVLB  1
32DA:  MOVWF  x99
32DC:  MOVLB  0
32DE:  CALL   06CE
32E2:  MOVLB  1
32E4:  BRA    2CA2
....................     }//while(1)) 
.................... }//main 
....................  
32E6:  SLEEP 
.................... void bipp(int sure, int sayi, long pin) { 
*
08FE:  MOVLB  1
0900:  CLRF   x97
....................     int a = 0; 
....................     for (a = 0; a < sayi; a++) { 
0902:  CLRF   x97
0904:  MOVF   x94,W
0906:  SUBWF  x97,W
0908:  BC    097C
....................         output_high(pin); 
090A:  MOVFF  195,198
090E:  MOVLW  01
0910:  MOVWF  x99
0912:  MOVLW  0F
0914:  MOVWF  x9B
0916:  MOVLW  89
0918:  MOVWF  x9A
091A:  MOVLB  0
091C:  RCALL  08BC
091E:  MOVFF  195,198
0922:  MOVLB  1
0924:  CLRF   x99
0926:  MOVLW  0F
0928:  MOVWF  x9B
092A:  MOVLW  92
092C:  MOVWF  x9A
092E:  MOVLB  0
0930:  RCALL  08BC
....................         delay_ms(sure / 2); 
0932:  BCF    FD8.0
0934:  MOVLB  1
0936:  RRCF   x93,W
0938:  MOVWF  x98
093A:  MOVWF  x99
093C:  MOVLB  0
093E:  RCALL  06CE
....................         output_low(pin); 
0940:  MOVFF  195,198
0944:  MOVLB  1
0946:  CLRF   x99
0948:  MOVLW  0F
094A:  MOVWF  x9B
094C:  MOVLW  89
094E:  MOVWF  x9A
0950:  MOVLB  0
0952:  RCALL  08BC
0954:  MOVFF  195,198
0958:  MOVLB  1
095A:  CLRF   x99
095C:  MOVLW  0F
095E:  MOVWF  x9B
0960:  MOVLW  92
0962:  MOVWF  x9A
0964:  MOVLB  0
0966:  RCALL  08BC
....................         delay_ms(sure / 2); 
0968:  BCF    FD8.0
096A:  MOVLB  1
096C:  RRCF   x93,W
096E:  MOVWF  x98
0970:  MOVWF  x99
0972:  MOVLB  0
0974:  RCALL  06CE
0976:  MOVLB  1
0978:  INCF   x97,F
097A:  BRA    0904
....................     } 
097C:  MOVLB  0
097E:  RETURN 0
.................... }// 
....................  
.................... void sens_adc_oku(void) { 
*
10BA:  MOVLB  1
10BC:  CLRF   x6E
10BE:  CLRF   x6D
10C0:  CLRF   x6F
....................     unsigned int16 _adc = 0; 
....................     int i = 0; 
....................  
....................     for (i = 5; i < 8; i++) { 
10C2:  MOVLW  05
10C4:  MOVWF  x6F
10C6:  MOVF   x6F,W
10C8:  SUBLW  07
10CA:  BNC   1124
....................         set_adc_channel(i); 
10CC:  RLCF   x6F,W
10CE:  MOVWF  00
10D0:  RLCF   00,F
10D2:  MOVLW  FC
10D4:  ANDWF  00,F
10D6:  MOVF   FC2,W
10D8:  ANDLW  83
10DA:  IORWF  00,W
10DC:  MOVWF  FC2
....................         delay_us(20); 
10DE:  MOVLW  6A
10E0:  MOVWF  00
10E2:  DECFSZ 00,F
10E4:  BRA    10E2
10E6:  NOP   
....................         _adc = read_adc(); 
10E8:  BSF    FC2.1
10EA:  BTFSC  FC2.1
10EC:  BRA    10EA
10EE:  MOVFF  FC3,16D
10F2:  MOVFF  FC4,16E
....................  
....................         if (i == 5) an_sv1 = _adc; 
10F6:  MOVF   x6F,W
10F8:  SUBLW  05
10FA:  BNZ   1104
10FC:  MOVFF  16E,5B
1100:  MOVFF  16D,5A
....................         if (i == 6) an_sv2 = _adc; 
1104:  MOVF   x6F,W
1106:  SUBLW  06
1108:  BNZ   1112
110A:  MOVFF  16E,5D
110E:  MOVFF  16D,5C
....................         if (i == 7) an_sv3 = _adc; 
1112:  MOVF   x6F,W
1114:  SUBLW  07
1116:  BNZ   1120
1118:  MOVFF  16E,5F
111C:  MOVFF  16D,5E
1120:  INCF   x6F,F
1122:  BRA    10C6
....................  
....................     } 
1124:  MOVLB  0
1126:  RETURN 0
....................  
....................     //printf(lcd_putc,"\f%Lu,%Lu,%Lu",an_sv1,an_sv2,an_sv3); 
.................... } 
....................  
.................... char *dilTxtGetir(char dil, int txt_sayi) { 
....................     char *txt; 
....................  
....................     if (dil == DIL_TR) txt = splitStr(lcd_tr, ",", txt_sayi); 
*
0BF4:  MOVLB  1
0BF6:  MOVF   x93,W
0BF8:  SUBLW  14
0BFA:  BNZ   0C46
0BFC:  MOVLW  01
0BFE:  MOVWF  FEA
0C00:  MOVLW  97
0C02:  MOVWF  FE9
0C04:  MOVLW  69
0C06:  MOVWF  01
0C08:  CLRF   FF7
0C0A:  MOVLW  00
0C0C:  MOVLB  0
0C0E:  CALL   018A
0C12:  TBLRD*-
0C14:  TBLRD*+
0C16:  MOVFF  FF5,FEE
0C1A:  DECFSZ 01,F
0C1C:  BRA    0C14
0C1E:  MOVLW  2C
0C20:  MOVLB  2
0C22:  MOVWF  x00
0C24:  CLRF   x01
0C26:  MOVLW  01
0C28:  MOVWF  x25
0C2A:  MOVLW  97
0C2C:  MOVWF  x24
0C2E:  MOVLW  02
0C30:  MOVWF  x27
0C32:  CLRF   x26
0C34:  MOVFF  194,228
0C38:  MOVLB  0
0C3A:  RCALL  0B8E
0C3C:  MOVFF  02,196
0C40:  MOVFF  01,195
0C44:  MOVLB  1
....................     if (dil == DIL_FR) txt = splitStr(lcd_fr, ",", txt_sayi); 
0C46:  MOVF   x93,W
0C48:  SUBLW  15
0C4A:  BNZ   0C98
0C4C:  MOVLW  01
0C4E:  MOVWF  FEA
0C50:  MOVLW  97
0C52:  MOVWF  FE9
0C54:  MOVLW  87
0C56:  MOVWF  01
0C58:  CLRF   FF7
0C5A:  MOVLW  00
0C5C:  MOVLB  0
0C5E:  CALL   0204
0C62:  TBLRD*-
0C64:  TBLRD*+
0C66:  MOVFF  FF5,FEE
0C6A:  DECFSZ 01,F
0C6C:  BRA    0C64
0C6E:  MOVLW  2C
0C70:  MOVLB  2
0C72:  MOVWF  x1E
0C74:  CLRF   x1F
0C76:  MOVLW  01
0C78:  MOVWF  x25
0C7A:  MOVLW  97
0C7C:  MOVWF  x24
0C7E:  MOVLW  02
0C80:  MOVWF  x27
0C82:  MOVLW  1E
0C84:  MOVWF  x26
0C86:  MOVFF  194,228
0C8A:  MOVLB  0
0C8C:  RCALL  0B8E
0C8E:  MOVFF  02,196
0C92:  MOVFF  01,195
0C96:  MOVLB  1
....................     if (dil == DIL_ALM) txt = splitStr(lcd_alm, ",", txt_sayi); 
0C98:  MOVF   x93,W
0C9A:  SUBLW  16
0C9C:  BNZ   0CEA
0C9E:  MOVLW  01
0CA0:  MOVWF  FEA
0CA2:  MOVLW  97
0CA4:  MOVWF  FE9
0CA6:  MOVLW  84
0CA8:  MOVWF  01
0CAA:  CLRF   FF7
0CAC:  MOVLW  00
0CAE:  MOVLB  0
0CB0:  CALL   029C
0CB4:  TBLRD*-
0CB6:  TBLRD*+
0CB8:  MOVFF  FF5,FEE
0CBC:  DECFSZ 01,F
0CBE:  BRA    0CB6
0CC0:  MOVLW  2C
0CC2:  MOVLB  2
0CC4:  MOVWF  x1B
0CC6:  CLRF   x1C
0CC8:  MOVLW  01
0CCA:  MOVWF  x25
0CCC:  MOVLW  97
0CCE:  MOVWF  x24
0CD0:  MOVLW  02
0CD2:  MOVWF  x27
0CD4:  MOVLW  1B
0CD6:  MOVWF  x26
0CD8:  MOVFF  194,228
0CDC:  MOVLB  0
0CDE:  RCALL  0B8E
0CE0:  MOVFF  02,196
0CE4:  MOVFF  01,195
0CE8:  MOVLB  1
....................     if (dil == DIL_ING) txt = splitStr(lcd_ing, ",", txt_sayi); 
0CEA:  MOVF   x93,W
0CEC:  SUBLW  17
0CEE:  BNZ   0D3C
0CF0:  MOVLW  01
0CF2:  MOVWF  FEA
0CF4:  MOVLW  97
0CF6:  MOVWF  FE9
0CF8:  MOVLW  75
0CFA:  MOVWF  01
0CFC:  CLRF   FF7
0CFE:  MOVLW  00
0D00:  MOVLB  0
0D02:  CALL   0330
0D06:  TBLRD*-
0D08:  TBLRD*+
0D0A:  MOVFF  FF5,FEE
0D0E:  DECFSZ 01,F
0D10:  BRA    0D08
0D12:  MOVLW  2C
0D14:  MOVLB  2
0D16:  MOVWF  x0C
0D18:  CLRF   x0D
0D1A:  MOVLW  01
0D1C:  MOVWF  x25
0D1E:  MOVLW  97
0D20:  MOVWF  x24
0D22:  MOVLW  02
0D24:  MOVWF  x27
0D26:  MOVLW  0C
0D28:  MOVWF  x26
0D2A:  MOVFF  194,228
0D2E:  MOVLB  0
0D30:  RCALL  0B8E
0D32:  MOVFF  02,196
0D36:  MOVFF  01,195
0D3A:  MOVLB  1
....................  
....................     return txt; 
0D3C:  MOVFF  195,01
0D40:  MOVFF  196,02
0D44:  MOVLB  0
0D46:  RETURN 0
.................... } 
....................  
....................  
.................... #define MAX_STRING_LEN 250   //splitStr için gerekli 
.................... //char *s = splitStr(buf_rf24_rcv, ",", 7); 
.................... //sprintf(text, "%Lu,%u,%u,%c,%4Lu,%u,%s", this_id, master_node, msg_id_say++, 'm', 
.................... //                                    panel_rastgele_renk, panel_rastgele_renk,s);// s yazýnca oldu 
....................  
.................... //    char *kimden = splitStr(msg, ",", 1); 
....................  
.................... char *splitStr(char *input_string, char *separator, int segment_number) //index 1 den ba?l?yor (segment_number) 
.................... { 
....................     //String ifadenin sonu her zaman '\0' karakteri olmal?d?r. Serial veri al?m?nda bu karakter string sonuna eklenmez. 
....................     //Bir stringe ?evirme i?leminde de eklenmeyebilir. String sonuna eklenmelidir. 
....................     //Split i?leminde string bir daha b?l?necekse sonuna muhakkak '\0' eklenmelidir. 
....................  
....................     char *act, *sub, *ptr; 
....................     static char copy[MAX_STRING_LEN]; 
....................     int i; 
....................  
....................     strcpy(copy, input_string); 
*
0B8E:  CLRF   FEA
0B90:  MOVLW  6F
0B92:  MOVWF  FE9
0B94:  MOVFF  225,FE2
0B98:  MOVFF  224,FE1
0B9C:  MOVF   FE7,F
0B9E:  MOVFF  FE6,FEE
0BA2:  BNZ   0B9C
....................  
....................     for (i = 1, act = copy; i <= segment_number; i++, act = NULL) { 
0BA4:  MOVLW  01
0BA6:  MOVLB  2
0BA8:  MOVWF  x2F
0BAA:  CLRF   x2A
0BAC:  MOVLW  6F
0BAE:  MOVWF  x29
0BB0:  MOVF   x2F,W
0BB2:  SUBWF  x28,W
0BB4:  BNC   0BE8
....................  
....................         sub = strtok(act, separator); 
0BB6:  MOVFF  22A,231
0BBA:  MOVFF  229,230
0BBE:  MOVFF  227,233
0BC2:  MOVFF  226,232
0BC6:  MOVLB  0
0BC8:  BRA    0AD0
0BCA:  MOVFF  02,22C
0BCE:  MOVFF  01,22B
....................         if (sub == NULL) 
0BD2:  MOVLB  2
0BD4:  MOVF   x2B,F
0BD6:  BNZ   0BDE
0BD8:  MOVF   x2C,F
0BDA:  BNZ   0BDE
....................             break; 
0BDC:  BRA    0BE8
0BDE:  MOVF   x2F,W
0BE0:  INCF   x2F,F
0BE2:  CLRF   x2A
0BE4:  CLRF   x29
0BE6:  BRA    0BB0
....................     } 
....................     return sub; 
0BE8:  MOVFF  22B,01
0BEC:  MOVFF  22C,02
0BF0:  MOVLB  0
0BF2:  RETURN 0
.................... } 
....................  
.................... unsigned long kul_say_ee_islem(char islem, unsigned int32 sayi) { 
....................     unsigned int8 b1, b2, b3, b4; 
....................  
....................  
....................     if (islem == KUL_SAY_EE_KAYDET) { 
*
0D48:  MOVLB  1
0D4A:  MOVF   x69,W
0D4C:  SUBLW  4B
0D4E:  BNZ   0E04
....................         write_eeprom(EE_ADR_KUL_SAY_BL, make8(sayi, 0)); 
0D50:  MOVFF  16A,172
0D54:  MOVF   FF2,W
0D56:  MOVWF  00
0D58:  BCF    FF2.7
0D5A:  MOVLW  01
0D5C:  MOVWF  FA9
0D5E:  MOVFF  172,FA8
0D62:  BCF    FA6.6
0D64:  BCF    FA6.7
0D66:  BSF    FA6.2
0D68:  MOVLB  F
0D6A:  MOVLW  55
0D6C:  MOVWF  FA7
0D6E:  MOVLW  AA
0D70:  MOVWF  FA7
0D72:  BSF    FA6.1
0D74:  BTFSC  FA6.1
0D76:  BRA    0D74
0D78:  BCF    FA6.2
0D7A:  MOVF   00,W
0D7C:  IORWF  FF2,F
....................         write_eeprom(EE_ADR_KUL_SAY_BL + 1, make8(sayi, 1)); 
0D7E:  MOVFF  16B,172
0D82:  MOVFF  FF2,00
0D86:  BCF    FF2.7
0D88:  MOVLW  02
0D8A:  MOVWF  FA9
0D8C:  MOVFF  16B,FA8
0D90:  BCF    FA6.6
0D92:  BCF    FA6.7
0D94:  BSF    FA6.2
0D96:  MOVLW  55
0D98:  MOVWF  FA7
0D9A:  MOVLW  AA
0D9C:  MOVWF  FA7
0D9E:  BSF    FA6.1
0DA0:  BTFSC  FA6.1
0DA2:  BRA    0DA0
0DA4:  BCF    FA6.2
0DA6:  MOVF   00,W
0DA8:  IORWF  FF2,F
....................         write_eeprom(EE_ADR_KUL_SAY_BL + 2, make8(sayi, 2)); 
0DAA:  MOVFF  16C,172
0DAE:  MOVFF  FF2,00
0DB2:  BCF    FF2.7
0DB4:  MOVLW  03
0DB6:  MOVWF  FA9
0DB8:  MOVFF  16C,FA8
0DBC:  BCF    FA6.6
0DBE:  BCF    FA6.7
0DC0:  BSF    FA6.2
0DC2:  MOVLW  55
0DC4:  MOVWF  FA7
0DC6:  MOVLW  AA
0DC8:  MOVWF  FA7
0DCA:  BSF    FA6.1
0DCC:  BTFSC  FA6.1
0DCE:  BRA    0DCC
0DD0:  BCF    FA6.2
0DD2:  MOVF   00,W
0DD4:  IORWF  FF2,F
....................         write_eeprom(EE_ADR_KUL_SAY_BL + 3, make8(sayi, 3)); 
0DD6:  MOVFF  16D,172
0DDA:  MOVFF  FF2,00
0DDE:  BCF    FF2.7
0DE0:  MOVLW  04
0DE2:  MOVWF  FA9
0DE4:  MOVFF  16D,FA8
0DE8:  BCF    FA6.6
0DEA:  BCF    FA6.7
0DEC:  BSF    FA6.2
0DEE:  MOVLW  55
0DF0:  MOVWF  FA7
0DF2:  MOVLW  AA
0DF4:  MOVWF  FA7
0DF6:  BSF    FA6.1
0DF8:  BTFSC  FA6.1
0DFA:  BRA    0DF8
0DFC:  BCF    FA6.2
0DFE:  MOVF   00,W
0E00:  IORWF  FF2,F
0E02:  MOVLB  1
....................     } 
....................  
....................     if (islem == KUL_SAY_EE_OKU) { 
0E04:  MOVF   x69,W
0E06:  SUBLW  4F
0E08:  BNZ   0E9C
....................         b1 = read_eeprom(EE_ADR_KUL_SAY_BL); 
0E0A:  MOVFF  FF2,172
0E0E:  BCF    FF2.7
0E10:  MOVLW  01
0E12:  MOVWF  FA9
0E14:  BCF    FA6.6
0E16:  BCF    FA6.7
0E18:  BSF    FA6.0
0E1A:  MOVF   FA8,W
0E1C:  BTFSC  x72.7
0E1E:  BSF    FF2.7
0E20:  MOVWF  x6E
....................         b2 = read_eeprom(EE_ADR_KUL_SAY_BL + 1); 
0E22:  MOVFF  FF2,172
0E26:  BCF    FF2.7
0E28:  MOVLW  02
0E2A:  MOVWF  FA9
0E2C:  BCF    FA6.6
0E2E:  BCF    FA6.7
0E30:  BSF    FA6.0
0E32:  MOVF   FA8,W
0E34:  BTFSC  x72.7
0E36:  BSF    FF2.7
0E38:  MOVWF  x6F
....................         b3 = read_eeprom(EE_ADR_KUL_SAY_BL + 1); 
0E3A:  MOVFF  FF2,172
0E3E:  BCF    FF2.7
0E40:  MOVLW  02
0E42:  MOVWF  FA9
0E44:  BCF    FA6.6
0E46:  BCF    FA6.7
0E48:  BSF    FA6.0
0E4A:  MOVF   FA8,W
0E4C:  BTFSC  x72.7
0E4E:  BSF    FF2.7
0E50:  MOVWF  x70
....................         b4 = read_eeprom(EE_ADR_KUL_SAY_BL + 1); 
0E52:  MOVFF  FF2,172
0E56:  BCF    FF2.7
0E58:  MOVLW  02
0E5A:  MOVWF  FA9
0E5C:  BCF    FA6.6
0E5E:  BCF    FA6.7
0E60:  BSF    FA6.0
0E62:  MOVF   FA8,W
0E64:  BTFSC  x72.7
0E66:  BSF    FF2.7
0E68:  MOVWF  x71
....................  
....................         if (b1 == 0xFF && b2 == 0xFF && b3 == 0xFF && b4 == 0xFF) return 0x00LL; 
0E6A:  INCFSZ x6E,W
0E6C:  BRA    0E84
0E6E:  INCFSZ x6F,W
0E70:  BRA    0E84
0E72:  INCFSZ x70,W
0E74:  BRA    0E84
0E76:  INCFSZ x71,W
0E78:  BRA    0E84
0E7A:  MOVLW  00
0E7C:  MOVWF  01
0E7E:  MOVWF  02
0E80:  BRA    0E9C
0E82:  BRA    0E9C
....................         else return make32(b4, b3, b2, b1); 
0E84:  MOVFF  171,03
0E88:  MOVFF  170,02
0E8C:  MOVFF  16F,01
0E90:  MOVFF  16E,00
0E94:  MOVFF  01,02
0E98:  MOVFF  00,01
....................     } 
0E9C:  MOVLB  0
0E9E:  RETURN 0
....................  
.................... } 
....................  

Configuration Fuses:
   Word  1: A800   INTRC_IO NOPLLEN PRIMARY_ON NOFCMEN IESO
   Word  2: 1E19   NOPUT NOBROWNOUT BORV19 WDT_SW WDT128
   Word  3: B500   CCP2C1 NOPBADEN CCP3B5 NOHFOFST TIMER3C0 CCP2D2 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: 8000   PROTECT CPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
